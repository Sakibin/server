{"version":3,"sources":["../src/index.ts","../src/lib/style-formatting/index.ts","../src/lib/style-formatting/style-serializer.ts","../src/lib/utils.ts"],"names":["lodashGet","value"],"mappings":"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","sourcesContent":["import type { AuthForHAR, DataForHAR, oasToHarOptions } from './lib/types.js';\nimport type { PostDataParams, Request } from 'har-format';\nimport type Oas from 'oas';\nimport type { Extensions } from 'oas/extensions';\nimport type { SchemaWrapper } from 'oas/operation/get-parameters-as-json-schema';\nimport type {\n  HttpMethods,\n  JSONSchema,\n  MediaTypeObject,\n  OASDocument,\n  OperationObject,\n  ParameterObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'oas/types';\n\nimport { parse as parseDataUrl } from '@readme/data-urls';\nimport lodashGet from 'lodash.get';\nimport lodashSet from 'lodash.set';\nimport { HEADERS, PROXY_ENABLED } from 'oas/extensions';\nimport { Operation } from 'oas/operation';\nimport { isRef } from 'oas/types';\nimport { jsonSchemaTypes, matchesMimeType } from 'oas/utils';\nimport removeUndefinedObjects from 'remove-undefined-objects';\n\nimport configureSecurity from './lib/configure-security.js';\nimport formatStyle from './lib/style-formatting/index.js';\nimport { getSafeRequestBody, getTypedFormatsInSchema, hasSchemaType } from './lib/utils.js';\n\nfunction formatter(\n  values: DataForHAR,\n  param: ParameterObject,\n  type: 'body' | 'cookie' | 'header' | 'path' | 'query',\n  onlyIfExists = false,\n) {\n  if (param.style) {\n    const value = values[type][param.name];\n    // Note: Technically we could send everything through the format style and choose the proper\n    // default for each `in` type (e.g. query defaults to form).\n    return formatStyle(value, param);\n  }\n\n  let value;\n\n  // Handle missing values\n  if (typeof values[type][param.name] !== 'undefined') {\n    value = values[type][param.name];\n  } else if (onlyIfExists && !param.required) {\n    value = undefined;\n  } else if (param.required && param.schema && !isRef(param.schema) && param.schema.default) {\n    value = param.schema.default;\n  } else if (type === 'path') {\n    // If we don't have any values for the path parameter, just use the name of the parameter as the\n    // value so we don't try try to build a URL to something like `https://example.com/undefined`.\n    return param.name;\n  }\n\n  // Handle file uploads. Specifically arrays of file uploads which need to be formatted very\n  // specifically.\n  if (\n    param.schema &&\n    !isRef(param.schema) &&\n    param.schema.type === 'array' &&\n    param.schema.items &&\n    !isRef(param.schema.items) &&\n    param.schema.items.format === 'binary'\n  ) {\n    if (Array.isArray(value)) {\n      // If this is array of binary data then we shouldn't do anything because we'll prepare them\n      // separately in the HAR in order to preserve `fileName` and `contentType` data within\n      // `postData.params`. If we don't then the HAR we generate for this data will be invalid.\n      return value;\n    }\n\n    return JSON.stringify(value);\n  }\n\n  if (value !== undefined) {\n    // Query params should always be formatted, even if they don't have a `style` serialization\n    // configured.\n    if (type === 'query') {\n      return formatStyle(value, param);\n    }\n\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction multipartBodyToFormatterParams(payload: unknown, oasMediaTypeObject: MediaTypeObject, schema: SchemaObject) {\n  const encoding = oasMediaTypeObject.encoding;\n\n  if (typeof payload === 'object' && payload !== null) {\n    return Object.keys(payload)\n      .map(key => {\n        // If we have an incoming parameter, but it's not in the schema ignore it.\n        if (!schema.properties[key]) {\n          return false;\n        }\n\n        const paramEncoding = encoding ? encoding[key] : undefined;\n\n        return {\n          name: key,\n          // If the style isn't defined, use the default\n          style: paramEncoding ? paramEncoding.style : undefined,\n          // If explode isn't defined, use the default\n          explode: paramEncoding ? paramEncoding.explode : undefined,\n          required:\n            (schema.required && typeof schema.required === 'boolean' && Boolean(schema.required)) ||\n            (Array.isArray(schema.required) && schema.required.includes(key)),\n          schema: schema.properties[key],\n          in: 'body',\n        };\n      })\n      .filter(Boolean) as ParameterObject[];\n  }\n\n  // Pretty sure that we'll never have anything but an object for multipart bodies, so returning\n  // empty array if we get anything else.\n  return [];\n}\n\nconst defaultFormDataTypes = Object.keys(jsonSchemaTypes).reduce((prev, curr) => {\n  return Object.assign(prev, { [curr]: {} });\n}, {});\n\nfunction getResponseContentType(content: MediaTypeObject) {\n  const types = Object.keys(content) || [];\n\n  // If this response content has multiple types available we should always prefer the one that's\n  // JSON-compatible. If they don't have one that is we'll return the first available, otherwise\n  // if they don't have **any** repsonse content types present we'll assume it's JSON.\n  if (types && types.length) {\n    const jsonType = types.find(t => matchesMimeType.json(t));\n    if (jsonType) {\n      return jsonType;\n    }\n\n    return types[0];\n  }\n\n  return 'application/json';\n}\n\nfunction isPrimitive(val: unknown) {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\n\nfunction stringify(json: Record<string | 'RAW_BODY', unknown>) {\n  return JSON.stringify(removeUndefinedObjects(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));\n}\n\nfunction stringifyParameter(param: any): string {\n  if (param === null || isPrimitive(param)) {\n    return param;\n  } else if (Array.isArray(param) && param.every(isPrimitive)) {\n    return String(param);\n  }\n\n  return JSON.stringify(param);\n}\n\nfunction appendHarValue(\n  harParam: Request['cookies'] | Request['headers'] | Request['queryString'] | PostDataParams['params'],\n  name: string,\n  value: any,\n  addtlData: {\n    contentType?: string;\n    fileName?: string;\n  } = {},\n) {\n  if (typeof value === 'undefined') return;\n\n  if (Array.isArray(value)) {\n    // If the formatter gives us an array, we're expected to add each array value as a new\n    // parameter item with the same parameter name\n    value.forEach(singleValue => {\n      appendHarValue(harParam, name, singleValue);\n    });\n  } else if (typeof value === 'object' && value !== null) {\n    // If the formatter gives us an object, we're expected to add each property value as a new\n    // parameter item, each with the name of the property\n    Object.keys(value).forEach(key => {\n      appendHarValue(harParam, key, value[key]);\n    });\n  } else {\n    // If the formatter gives us a non-array, non-object, we add it as is\n    harParam.push({\n      ...addtlData,\n      name,\n      value: String(value),\n    });\n  }\n}\n\nfunction encodeBodyForHAR(body: any) {\n  if (isPrimitive(body)) {\n    return body;\n  } else if (\n    typeof body === 'object' &&\n    body !== null &&\n    !Array.isArray(body) &&\n    typeof body.RAW_BODY !== 'undefined'\n  ) {\n    // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload as a\n    // raw string. https://docs.readme.com/docs/raw-body-content\n    if (isPrimitive(body.RAW_BODY)) {\n      return body.RAW_BODY;\n    }\n\n    return stringify(body.RAW_BODY);\n  }\n\n  return stringify(body);\n}\n\nexport default function oasToHar(\n  oas: Oas,\n  operationSchema?: Operation,\n  values: DataForHAR = {},\n  auth: AuthForHAR = {},\n  opts: oasToHarOptions = {\n    // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in\n    // order to funnel requests through our CORS-friendly proxy.\n    proxyUrl: false,\n  },\n) {\n  let operation: Operation;\n  if (!operationSchema || typeof operationSchema.getParameters !== 'function') {\n    /**\n     * If `operationSchema` was supplied as a plain object instead of an instance of `Operation`\n     * then we should create a new instance of it. We're doing it with a check on `getParameters`\n     * instead of checking `instanceof Operation` because JS is very weird when it comes to\n     * checking `instanceof` against classes. One instance of `Operation` may not always match up\n     * with another if they're being loaded between two different libraries.\n     *\n     * It's weird. This is easier.\n     */\n    operation = new Operation(\n      oas as unknown as OASDocument,\n      operationSchema?.path || '',\n      operationSchema?.method || ('' as HttpMethods),\n      (operationSchema as unknown as OperationObject) || { path: '', method: '' },\n    );\n  } else {\n    operation = operationSchema;\n  }\n\n  const apiDefinition = oas.getDefinition();\n\n  const formData: DataForHAR = {\n    ...defaultFormDataTypes,\n    server: {\n      selected: 0,\n      variables: oas.defaultVariables(0),\n    },\n    ...values,\n  };\n\n  // If the incoming `server.variables` is missing variables let's pad it out with defaults.\n  formData.server.variables = {\n    ...oas.defaultVariables(formData.server.selected),\n    ...(formData.server.variables ? formData.server.variables : {}),\n  };\n\n  const har: Request = {\n    cookies: [],\n    headers: [],\n    headersSize: 0,\n    queryString: [],\n    // @ts-expect-error This is fine because we're fleshing `postData` out further down.\n    postData: {},\n    bodySize: 0,\n    method: operation.method.toUpperCase(),\n    url: `${oas.url(formData.server.selected, formData.server.variables)}${operation.path}`.replace(/\\s/g, '%20'),\n    httpVersion: 'HTTP/1.1',\n  };\n\n  if (opts.proxyUrl) {\n    if (oas.getExtension(PROXY_ENABLED, operation)) {\n      har.url = `https://try.readme.io/${har.url}`;\n    }\n  }\n\n  const parameters = operation.getParameters();\n\n  har.url = har.url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, (full, key) => {\n    if (!operation || !parameters) return key; // No path params at all\n\n    // Find the path parameter or set a default value if it does not exist\n    const parameter = parameters.find(param => param.name === key) || ({ name: key } as ParameterObject);\n\n    // The library that handles our style processing already encodes uri elements. For everything\n    // else we need to handle it here.\n    if (!('style' in parameter) || !parameter.style) {\n      return encodeURIComponent(formatter(formData, parameter, 'path'));\n    }\n\n    return formatter(formData, parameter, 'path');\n  });\n\n  const queryStrings = parameters && parameters.filter(param => param.in === 'query');\n  if (queryStrings && queryStrings.length) {\n    queryStrings.forEach(queryString => {\n      const value = formatter(formData, queryString, 'query', true);\n      appendHarValue(har.queryString, queryString.name, value);\n    });\n  }\n\n  // Do we have any `cookie` parameters on the operation?\n  const cookies = parameters && parameters.filter(param => param.in === 'cookie');\n  if (cookies && cookies.length) {\n    cookies.forEach(cookie => {\n      const value = formatter(formData, cookie, 'cookie', true);\n      appendHarValue(har.cookies, cookie.name, value);\n    });\n  }\n\n  // Does this response have any documented content types?\n  if (operation.schema.responses) {\n    Object.keys(operation.schema.responses).some(response => {\n      if (isRef(operation.schema.responses[response])) return false;\n\n      const content = (operation.schema.responses[response] as ResponseObject).content;\n      if (!content) return false;\n\n      // If there's no `accept` header present we should add one so their eventual code snippet\n      // follows best practices.\n      if (Object.keys(formData.header).find(h => h.toLowerCase() === 'accept')) return true;\n\n      har.headers.push({\n        name: 'accept',\n        value: getResponseContentType(content),\n      });\n\n      return true;\n    });\n  }\n\n  // Do we have any `header` parameters on the operation?\n  let hasContentType = false;\n  let contentType = operation.getContentType();\n  const headers = parameters && parameters.filter(param => param.in === 'header');\n  if (headers && headers.length) {\n    headers.forEach(header => {\n      const value = formatter(formData, header, 'header', true);\n      if (typeof value === 'undefined') return;\n\n      if (header.name.toLowerCase() === 'content-type') {\n        hasContentType = true;\n        contentType = String(value);\n      }\n\n      appendHarValue(har.headers, header.name, value);\n    });\n  }\n\n  // Are there `x-headers` static headers configured for this OAS?\n  const userDefinedHeaders = oas.getExtension(HEADERS, operation) as Extensions['headers'];\n  if (userDefinedHeaders) {\n    userDefinedHeaders.forEach(header => {\n      if (typeof header.key === 'string' && header.key.toLowerCase() === 'content-type') {\n        hasContentType = true;\n        contentType = String(header.value);\n      }\n\n      har.headers.push({\n        name: String(header.key),\n        value: String(header.value),\n      });\n    });\n  }\n\n  if (formData.header) {\n    // Do we have an `accept` header set up in the form data, but it hasn't been added yet?\n    const acceptHeader = Object.keys(formData.header).find(h => h.toLowerCase() === 'accept');\n    if (acceptHeader && !har.headers.find(hdr => hdr.name.toLowerCase() === 'accept')) {\n      har.headers.push({\n        name: 'accept',\n        value: String(formData.header[acceptHeader]),\n      });\n    }\n\n    // Do we have a manually-defined `authorization` header set up in the form data?\n    const authorizationHeader = Object.keys(formData.header).find(h => h.toLowerCase() === 'authorization');\n    if (authorizationHeader && !har.headers.find(hdr => hdr.name.toLowerCase() === 'authorization')) {\n      har.headers.push({\n        name: 'authorization',\n        value: String(formData.header[authorizationHeader]),\n      });\n    }\n  }\n\n  let requestBody: SchemaWrapper;\n  if (operation.hasRequestBody()) {\n    requestBody = operation.getParametersAsJSONSchema().find(payload => {\n      // `formData` is used in our API Explorer for `application/x-www-form-urlencoded` endpoints\n      // and if you have an operation with that, it will only ever have a `formData`. `body` is\n      // used for all other payload shapes.\n      return payload.type === (operation.isFormUrlEncoded() ? 'formData' : 'body');\n    });\n  }\n\n  if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {\n    const requestBodySchema = requestBody.schema as SchemaObject;\n\n    if (operation.isFormUrlEncoded()) {\n      if (Object.keys(formData.formData).length) {\n        const cleanFormData = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.formData)));\n        if (cleanFormData !== undefined) {\n          har.postData.params = [];\n          har.postData.mimeType = 'application/x-www-form-urlencoded';\n\n          Object.keys(cleanFormData).forEach(name => {\n            har.postData.params.push({\n              name,\n              value: stringifyParameter(cleanFormData[name]),\n            });\n          });\n        }\n      }\n    } else if (\n      'body' in formData &&\n      formData.body !== undefined &&\n      (isPrimitive(formData.body) || Object.keys(formData.body).length)\n    ) {\n      const isMultipart = operation.isMultipart();\n      const isJSON = operation.isJson();\n\n      if (isMultipart || isJSON) {\n        try {\n          let cleanBody = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.body)));\n\n          if (isMultipart) {\n            har.postData.mimeType = 'multipart/form-data';\n            har.postData.params = [];\n\n            // Because some request body schema shapes might not always be a top-level `properties`,\n            // instead nesting it in an `oneOf` or `anyOf` we need to extract the first usable\n            // schema that we have in order to process this multipart payload.\n            const safeBodySchema = getSafeRequestBody(requestBodySchema);\n\n            /**\n             * Discover all `{ type: string, format: binary }` properties, or arrays containing the\n             * same, within the request body. If there are any, then that means that we're dealing\n             * with a `multipart/form-data` request and need to treat the payload as\n             * `postData.params` and supply filenames and content types for the files (if they're\n             * available).\n             *\n             * @todo It'd be nice to replace this with `getTypedFormatsInSchema` instead.\n             * @example `{ type: string, format: binary }`\n             * @example `{ type: array, items: { type: string, format: binary } }`\n             */\n            const binaryTypes = Object.keys(safeBodySchema.properties).filter(key => {\n              const propData = safeBodySchema.properties[key] as JSONSchema;\n              if (propData.format === 'binary') {\n                return true;\n              } else if (\n                propData.type === 'array' &&\n                propData.items &&\n                typeof propData.items === 'object' &&\n                propData.items !== null &&\n                (propData.items as JSONSchema).format === 'binary'\n              ) {\n                return true;\n              }\n\n              return false;\n            });\n\n            if (cleanBody !== undefined) {\n              const multipartParams = multipartBodyToFormatterParams(\n                formData.body,\n                (operation.schema.requestBody as RequestBodyObject).content['multipart/form-data'],\n                safeBodySchema,\n              );\n\n              if (multipartParams.length) {\n                Object.keys(cleanBody).forEach(name => {\n                  const param = multipartParams.find(multipartParam => multipartParam.name === name);\n\n                  // If we're dealing with a binary type, and the value is a valid data URL we should\n                  // parse out any available filename and content type to send along with the\n                  // parameter to interpreters like `fetch-har` can make sense of it and send a usable\n                  // payload.\n                  const addtlData: { contentType?: string; fileName?: string } = {};\n\n                  let value = formatter(formData, param, 'body', true);\n                  if (!Array.isArray(value)) {\n                    value = [value];\n                  }\n\n                  value.forEach((val: string) => {\n                    if (binaryTypes.includes(name)) {\n                      const parsed = parseDataUrl(val);\n                      if (parsed) {\n                        addtlData.fileName = 'name' in parsed ? parsed.name : 'unknown';\n                        if ('contentType' in parsed) {\n                          addtlData.contentType = parsed.contentType;\n                        }\n                      }\n                    }\n\n                    appendHarValue(har.postData.params, name, val, addtlData);\n                  });\n                });\n              }\n            }\n          } else {\n            har.postData.mimeType = contentType;\n\n            if (\n              hasSchemaType(requestBody.schema, 'string') ||\n              hasSchemaType(requestBody.schema, 'integer') ||\n              hasSchemaType(requestBody.schema, 'number') ||\n              hasSchemaType(requestBody.schema, 'boolean')\n            ) {\n              har.postData.text = JSON.stringify(JSON.parse(cleanBody));\n            } else {\n              /**\n               * Handle formatted JSON objects that have properties that accept arbitrary JSON.\n               *\n               * Find all `{ type: string, format: json }` properties in the schema because we need\n               * to manually `JSON.parse` them before submit, otherwise they'll be escaped instead\n               * of actual objects. We also only want values that the user has entered, so we drop\n               * any `undefined` `cleanBody` keys.\n               */\n              const jsonTypes = getTypedFormatsInSchema('json', requestBodySchema.properties, { payload: cleanBody });\n\n              if (Array.isArray(jsonTypes) && jsonTypes.length) {\n                try {\n                  jsonTypes.forEach((prop: string) => {\n                    try {\n                      lodashSet(cleanBody, prop, JSON.parse(lodashGet(cleanBody, prop)));\n                    } catch (e) {\n                      // leave the prop as a string value\n                    }\n                  });\n\n                  // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload\n                  // as a raw string. https://docs.readme.com/docs/raw-body-content\n                  if (typeof cleanBody.RAW_BODY !== 'undefined') {\n                    cleanBody = cleanBody.RAW_BODY;\n                  }\n\n                  har.postData.text = JSON.stringify(cleanBody);\n                } catch (e) {\n                  har.postData.text = stringify(formData.body);\n                }\n              } else {\n                har.postData.text = encodeBodyForHAR(formData.body);\n              }\n            }\n          }\n        } catch (e) {\n          // If anything above fails for whatever reason, assume that whatever we had is invalid\n          // JSON and just treat it as raw text.\n          har.postData.text = stringify(formData.body);\n        }\n      } else {\n        har.postData.mimeType = contentType;\n        har.postData.text = encodeBodyForHAR(formData.body);\n      }\n    }\n  }\n\n  // Add a `content-type` header if there are any body values setup above or if there is a schema\n  // defined, but only do so if we don't already have a `content-type` present as it's impossible\n  // for a request to have multiple.\n  if (\n    (har.postData.text || (requestBody && requestBody.schema && Object.keys(requestBody.schema).length)) &&\n    !hasContentType\n  ) {\n    har.headers.push({\n      name: 'content-type',\n      value: contentType,\n    });\n  }\n\n  const securityRequirements = operation.getSecurity();\n\n  if (securityRequirements && securityRequirements.length) {\n    // TODO pass these values through the formatter?\n    securityRequirements.forEach(schemes => {\n      Object.keys(schemes).forEach(security => {\n        const securityValue = configureSecurity(apiDefinition, auth, security);\n        if (!securityValue) {\n          return;\n        }\n\n        // If this is an `authorization` header and we've already added one (maybe one was manually\n        // specified), then we shouldn't add another.\n        if (securityValue.value.name === 'authorization') {\n          if (har[securityValue.type].find(v => v.name === securityValue.value.name)) {\n            return;\n          }\n        }\n\n        // If we've already added this **specific** security value then don't add it again.\n        if (\n          har[securityValue.type].find(\n            v => v.name === securityValue.value.name && v.value === securityValue.value.value,\n          )\n        ) {\n          return;\n        }\n\n        har[securityValue.type].push(securityValue.value);\n      });\n    });\n  }\n\n  // If we didn't end up filling the `postData` object then we don't need it.\n  if (Object.keys(har.postData).length === 0) {\n    delete har.postData;\n  }\n\n  return {\n    log: {\n      entries: [\n        {\n          request: har,\n        },\n      ],\n    },\n  };\n}\n","import type { StylizerConfig } from './style-serializer.js';\nimport type { ParameterObject, SchemaObject } from 'oas/types';\n\nimport qs from 'qs';\n\nimport { stylize } from './style-serializer.js';\n\n// Certain styles don't support empty values.\nfunction shouldNotStyleEmptyValues(parameter: ParameterObject) {\n  return ['simple', 'spaceDelimited', 'pipeDelimited', 'deepObject'].includes(parameter.style);\n}\n\nfunction shouldNotStyleReservedHeader(parameter: ParameterObject) {\n  return ['accept', 'authorization', 'content-type'].includes(parameter.name.toLowerCase());\n}\n\n/**\n * Note: This isn't necessarily part of the spec. Behavior for the value 'undefined' is, well,\n * undefined. This code makes our system look better. If we wanted to be more accurate, we might\n * want to remove this, restore the un-fixed behavior for undefined and have our UI pass in empty\n * string instead of undefined.\n */\nfunction removeUndefinedForPath(value: any) {\n  let finalValue = value;\n\n  if (typeof finalValue === 'undefined') {\n    return '';\n  }\n\n  if (Array.isArray(finalValue)) {\n    finalValue = finalValue.filter(val => (val === undefined ? '' : val));\n\n    if (finalValue.length === 0) {\n      finalValue = '';\n    }\n  }\n\n  if (typeof finalValue === 'object') {\n    Object.keys(finalValue).forEach(key => {\n      finalValue[key] = finalValue[key] === undefined ? '' : finalValue[key];\n    });\n  }\n\n  return finalValue;\n}\n\nfunction stylizeValue(value: unknown, parameter: ParameterObject) {\n  let finalValue = value;\n\n  // Some styles don't work with empty values. We catch those there\n  if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === 'undefined' || finalValue === '')) {\n    // Paths need return an unstyled empty string instead of undefined so it's ignored in the final\n    // path string.\n    if (parameter.in === 'path') {\n      return '';\n    }\n\n    // Everything but path should return undefined when unstyled so it's ignored in the final\n    // parameter array.\n    return undefined;\n  }\n\n  // Every style that adds their style to empty values should use emptystring for path parameters\n  // instead of undefined to avoid the string `undefined`.\n  if (parameter.in === 'path') {\n    finalValue = removeUndefinedForPath(finalValue);\n  }\n\n  /**\n   * Eventhough `accept`, `authorization`, and `content-type` headers can be defined as parameters,\n   * they should be completely ignored when it comes to serialization.\n   *\n   *  > If `in` is \"header\" and the `name` field is \"Accept\", \"Content-Type\" or \"Authorization\", the\n   *  > parameter definition SHALL be ignored.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#fixed-fields-10}\n   */\n  if (parameter.in === 'header' && shouldNotStyleReservedHeader(parameter)) {\n    return value;\n  }\n\n  /**\n   * All parameter types have a default `style` format so if they don't have one prescribed we\n   * should still conform to what the spec defines.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterstyle}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterstyle}\n   */\n  let style = parameter.style;\n  if (!style) {\n    if (parameter.in === 'query') {\n      style = 'form';\n    } else if (parameter.in === 'path') {\n      style = 'simple';\n    } else if (parameter.in === 'header') {\n      style = 'simple';\n    } else if (parameter.in === 'cookie') {\n      style = 'form';\n    }\n  }\n\n  let explode = parameter.explode;\n  if (explode === undefined && style === 'form') {\n    /**\n     * Per the spec if no `explode` is present but `style` is `form` then `explode` should default to `true`.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterexplode}\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterexplode}\n     */\n    explode = true;\n  }\n\n  return stylize({\n    location: parameter.in as StylizerConfig['location'],\n    value: finalValue,\n    key: parameter.name,\n    style: style as StylizerConfig['style'],\n    explode,\n    /**\n     * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or \"unsafe\".\n     *  I do not know if it is correct for query to use this. See style-serializer for more info\n     */\n    escape: true,\n    ...(parameter.in === 'query' ? { isAllowedReserved: parameter.allowReserved || false } : {}),\n  });\n}\n\nfunction handleDeepObject(value: any, parameter: ParameterObject) {\n  return qs\n    .stringify(value, {\n      // eslint-disable-next-line consistent-return\n      encoder(str, defaultEncoder, charset, type) {\n        if (type === 'key') {\n          // `str` will be here as `dog[treats][0]` but because the `qs` library doesn't have any\n          // awareness of our OpenAPI parameters we need to rewrite it to slap the `parameter.name`\n          // to the top, like `pets[dog][treats][0]`.\n          const prefixedKey = str\n            .split(/[[\\]]/g)\n            .filter(Boolean)\n            .map((k: string) => `[${k}]`)\n            .join('');\n\n          return `${parameter.name}${prefixedKey}`;\n        } else if (type === 'value') {\n          return stylizeValue(str, parameter);\n        }\n      },\n    })\n    .split('&')\n    .map(item => {\n      const split = item.split('=');\n      return {\n        label: split[0],\n        // `qs` will coerce null values into being `undefined` string but we want to preserve them.\n        value: split[1] === 'undefined' ? null : split[1],\n      };\n    });\n}\n\n// Explode is handled on its own, because style-serializer doesn't return what we expect for proper\n// HAR output.\nfunction handleExplode(value: any, parameter: ParameterObject) {\n  // This is to handle the case of arrays of objects in the querystring\n  // which is something that's not technically in the spec but since we're\n  // using the `qs` module already, it's fairly easy for us to add support\n  // for this use case.\n  //\n  // An example URL would be something like this:\n  // https://example.com/?line_items[0][a_string]=abc&line_items[0][quantity]=1&line_items[1][a_string]=def&line_items[1][quantity]=2\n  //\n  // Some open issues discussing this here:\n  // https://github.com/OAI/OpenAPI-Specification/issues/1706\n  // https://github.com/OAI/OpenAPI-Specification/issues/1006\n  //\n  // Link to the spec for this:\n  // https://github.com/OAI/OpenAPI-Specification/blob/36a3a67264cc1c4f1eff110cea3ebfe679435108/versions/3.1.0.md#style-examples\n  if (\n    Array.isArray(value) &&\n    (parameter.schema as SchemaObject)?.type === 'array' &&\n    parameter.style === 'deepObject'\n  ) {\n    const newObj: Record<string, unknown> = {};\n    const deepObjs = handleDeepObject(value, parameter);\n    deepObjs.forEach(obj => {\n      newObj[obj.label] = obj.value;\n    });\n    return newObj;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(val => {\n      return stylizeValue(val, parameter);\n    });\n  }\n\n  if (typeof value === 'object' && value !== null) {\n    const newObj: Record<string, unknown> = {};\n\n    Object.keys(value).forEach(key => {\n      if (parameter.style === 'deepObject') {\n        const deepObjs = handleDeepObject(value, parameter);\n        deepObjs.forEach(obj => {\n          newObj[obj.label] = obj.value;\n        });\n      } else {\n        newObj[key] = stylizeValue(value[key], parameter);\n      }\n    });\n\n    return newObj;\n  }\n\n  return stylizeValue(value, parameter);\n}\n\nfunction shouldExplode(parameter: ParameterObject) {\n  return (\n    (parameter.explode ||\n      (parameter.explode !== false && parameter.style === 'form') ||\n      // style: deepObject && explode: false doesn't exist so explode it always\n      // https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples\n      parameter.style === 'deepObject') &&\n    // header and path doesn't explode into separate parameters like query and cookie do\n    parameter.in !== 'header' &&\n    parameter.in !== 'path'\n  );\n}\n\nexport default function formatStyle(value: unknown, parameter: ParameterObject) {\n  // Deep object style only works on objects and arrays, and only works with explode=true.\n  if (parameter.style === 'deepObject' && (!value || typeof value !== 'object' || parameter.explode === false)) {\n    return undefined;\n  }\n\n  // This custom explode logic allows us to bubble up arrays and objects to be handled differently\n  // by our HAR transformer. We need this because the `stylizeValue` function assumes we're building\n  // strings, not richer data types.\n  //\n  // The first part of this conditional checks if `explode` is enabled. Explode is disabled for\n  // everything by default except for forms.\n  //\n  // The second part of this conditional bypasses the custom explode logic for headers, because they\n  // work differently, and `stylizeValue` is accurate.\n  if (shouldExplode(parameter)) {\n    return handleExplode(value, parameter);\n  }\n\n  return stylizeValue(value, parameter);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable no-param-reassign */\nimport type { Merge } from 'type-fest';\n\n/**\n * This file has been extracted and modified from `swagger-client`.\n *\n * @license Apache 2.0\n * @link https://npm.im/swagger-client\n * @link https://github.com/swagger-api/swagger-js/blob/master/src/execute/oas3/style-serializer.js\n */\n\nconst isRfc3986Reserved = (char: string) => \":/?#[]@!$&'()*+,;=\".indexOf(char) > -1;\nconst isRfc3986Unreserved = (char: string) => /^[a-z0-9\\-._~]+$/i.test(char);\n\nfunction isURIEncoded(value: string) {\n  try {\n    return decodeURIComponent(value) !== value;\n  } catch (err) {\n    // `decodeURIComponent` will throw an exception if a string that has an un-encoded percent sign\n    //  in it (like 20%), o if it's throwing we can just assume that the value hasn't been encoded.\n    return false;\n  }\n}\n\nfunction isObject(value: unknown) {\n  return typeof value === 'object' && value !== null;\n}\n\nexport function encodeDisallowedCharacters(\n  str: string,\n  {\n    escape,\n    returnIfEncoded = false,\n    isAllowedReserved,\n  }: {\n    escape?: boolean | 'unsafe';\n    isAllowedReserved?: boolean;\n    returnIfEncoded?: boolean;\n  } = {},\n  parse?: boolean,\n) {\n  if (typeof str === 'number') {\n    str = (str as number).toString();\n  }\n\n  if (returnIfEncoded) {\n    if (isURIEncoded(str)) {\n      return str;\n    }\n  }\n\n  if (typeof str !== 'string' || !str.length) {\n    return str;\n  }\n\n  if (!escape) {\n    return str;\n  }\n\n  if (parse) {\n    return JSON.parse(str);\n  }\n\n  // In ES6 you can do this quite easily by using the new ... spread operator. This causes the\n  // string iterator (another new ES6 feature) to be used internally, and because that iterator is\n  // designed to deal with code points rather than UCS-2/UTF-16 code units.\n  return [...str]\n    .map(char => {\n      if (isRfc3986Unreserved(char)) {\n        return char;\n      }\n\n      if (isRfc3986Reserved(char) && (escape === 'unsafe' || isAllowedReserved)) {\n        return char;\n      }\n\n      const encoder = new TextEncoder();\n      const encoded = Array.from(encoder.encode(char))\n        .map(byte => `0${byte.toString(16).toUpperCase()}`.slice(-2))\n        .map(encodedByte => `%${encodedByte}`)\n        .join('');\n\n      return encoded;\n    })\n    .join('');\n}\n\nexport interface StylizerConfig {\n  escape: boolean | 'unsafe';\n  explode: boolean;\n  isAllowedReserved?: boolean;\n  key: string;\n  location: 'body' | 'query';\n  style: 'deepObject' | 'form' | 'label' | 'matrix' | 'pipeDelimited' | 'simple' | 'spaceDelimited';\n  value: any;\n}\n\nexport function stylize(config: StylizerConfig) {\n  const { value } = config;\n\n  if (Array.isArray(value)) {\n    return encodeArray(config);\n  }\n\n  if (isObject(value)) {\n    return encodeObject(config);\n  }\n\n  return encodePrimitive(config);\n}\n\n/**\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples}\n */\nfunction encodeArray({\n  location,\n  key,\n  value,\n  style,\n  explode,\n  escape,\n  isAllowedReserved = false,\n}: Merge<StylizerConfig, { value: string[] }>) {\n  const valueEncoder = (str: string) =>\n    encodeDisallowedCharacters(str, {\n      escape,\n      returnIfEncoded: location === 'query',\n      isAllowedReserved,\n    });\n\n  switch (style) {\n    /**\n     * @example <caption>`style: simple`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `blue,black,brown`\n     */\n    case 'simple':\n      return value.map(val => valueEncoder(val)).join(',');\n\n    /**\n     * @example <caption>`style: label`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `.blue.black.brown`\n     */\n    case 'label':\n      return `.${value.map(val => valueEncoder(val)).join('.')}`;\n\n    /**\n     * @example <caption>`style: matrix` + `explode: true`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `;color=blue;color=black;color=brown`\n     *\n     * @example <caption>`style: matrix` + `explode: false` (the default behavior)</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `;color=blue,black,brown\t`\n     */\n    case 'matrix':\n      return value\n        .map(val => valueEncoder(val))\n        .reduce((prev, curr) => {\n          if (!prev || explode) {\n            return `${prev || ''};${key}=${curr}`;\n          }\n          return `${prev},${curr}`;\n        }, '');\n\n    /**\n     * @example <caption>`style: form` + `explode: true`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `color=blue&color=black&color=brown`\n     *\n     * @example <caption>`style: form` + `explode: false` (the default behavior)</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `color=blue,black,brown`\n     */\n    case 'form':\n      return value.map(val => valueEncoder(val)).join(explode ? `&${key}=` : ',');\n\n    /**\n     * @example <caption>`style: spaceDelimited`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `blue%20black%20brown`\n     */\n    case 'spaceDelimited':\n      return value.map(val => valueEncoder(val)).join(` ${explode ? `${key}=` : ''}`);\n\n    /**\n     * @example <caption>`style: pipeDelimited`</caption>\n     * `[\"blue\",\"black\",\"brown\"]` → `blue|black|brown`\n     */\n    case 'pipeDelimited':\n      return value.map(val => valueEncoder(val)).join(`|${explode ? `${key}=` : ''}`);\n\n    default:\n      return undefined;\n  }\n}\n\n/**\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples}\n */\nfunction encodeObject({ location, key, value, style, explode, escape, isAllowedReserved = false }: StylizerConfig) {\n  const valueEncoder = (str: string) =>\n    encodeDisallowedCharacters(str, {\n      escape,\n      returnIfEncoded: location === 'query',\n      isAllowedReserved,\n    });\n\n  const valueKeys = Object.keys(value);\n\n  switch (style) {\n    /**\n     * @example <caption>`style: simple` + `explode: true`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `R=100,G=200,B=150`\n     *\n     * @example <caption>`style: simple` + `explode: false` (the default behavior)</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `R,100,G,200,B,150`\n     */\n    case 'simple':\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const middleChar = explode ? '=' : ',';\n        const prefix = prev ? `${prev},` : '';\n\n        return `${prefix}${curr}${middleChar}${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: label` + `explode: true`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `.R=100.G=200.B=150`\n     *\n     * @example <caption>`style: label` + `explode: false` (the default behavior)</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `.R.100.G.200.B.150`\n     */\n    case 'label':\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const middleChar = explode ? '=' : '.';\n        const prefix = prev ? `${prev}.` : '.';\n\n        return `${prefix}${curr}${middleChar}${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: matrix` + `explode: true`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `;R=100;G=200;B=150`\n     *\n     * @example <caption>`style: matrix` + `explode: false` (the default behavior)</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `;color=R,100,G,200,B,150`\n     */\n    case 'matrix':\n      if (explode) {\n        return valueKeys.reduce((prev, curr) => {\n          const val = valueEncoder(value[curr]);\n          const prefix = prev ? `${prev};` : ';';\n\n          return `${prefix}${curr}=${val}`;\n        }, '');\n      }\n\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const prefix = prev ? `${prev},` : `;${key}=`;\n\n        return `${prefix}${curr},${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: form` + `explode: true`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `R=100&G=200&B=150`\n     *\n     * @example <caption>`style: form` + `explode: false` (the default behavior)</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `color=R,100,G,200,B,150`\n     */\n    case 'form':\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const prefix = prev ? `${prev}${explode ? '&' : ','}` : '';\n        const separator = explode ? '=' : ',';\n\n        return `${prefix}${curr}${separator}${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: spaceDelimited`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `R%20100%20G%20200%20B%20150`\n     */\n    case 'spaceDelimited':\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const prefix = prev ? `${prev} ` : '';\n\n        return `${prefix}${curr} ${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: pipeDelimited`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `R|100|G|200|B|150`\n     */\n    case 'pipeDelimited':\n      return valueKeys.reduce((prev, curr) => {\n        const val = valueEncoder(value[curr]);\n        const prefix = prev ? `${prev}|` : '';\n\n        return `${prefix}${curr}|${val}`;\n      }, '');\n\n    /**\n     * @example <caption>`style: deepObject`</caption>\n     * `{ \"R\": 100, \"G\": 200, \"B\": 150 }` → `color[R]=100&color[G]=200&color[B]=150`\n     */\n    case 'deepObject':\n      return valueKeys.reduce(curr => {\n        const val = valueEncoder(value[curr]);\n        return `${val}`;\n      }, '');\n\n    default:\n      return undefined;\n  }\n}\n\n/**\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples}\n */\nfunction encodePrimitive({ location, key, value, style, escape, isAllowedReserved = false }: StylizerConfig) {\n  const valueEncoder = (str: string) =>\n    encodeDisallowedCharacters(str, {\n      escape,\n      returnIfEncoded: location === 'query' || location === 'body',\n      isAllowedReserved,\n    });\n\n  switch (style) {\n    /**\n     * @example <caption>`style: simple`</caption>\n     * `blue` → `blue`\n     */\n    case 'simple':\n      return valueEncoder(value);\n\n    /**\n     * @example <caption>`style: label`</caption>\n     * `blue` → `.blue`\n     */\n    case 'label':\n      return `.${valueEncoder(value)}`;\n\n    /**\n     * @example <caption>`style: matrix`</caption>\n     * `blue` → `;color=blue`\n     */\n    case 'matrix':\n      if (value === '') {\n        return `;${key}`;\n      }\n\n      return `;${key}=${valueEncoder(value)}`;\n\n    /**\n     * @example <caption>`style: form`</caption>\n     * `blue` → `color=blue`\n     */\n    case 'form':\n      return valueEncoder(value);\n\n    /**\n     * @example <caption>`style: deepObject`</caption>\n     * `blue` → n/a\n     */\n    case 'deepObject':\n      return valueEncoder(value);\n\n    default:\n      return undefined;\n  }\n}\n","import type { JSONSchema, SchemaObject } from 'oas/types';\n\nimport lodashGet from 'lodash.get';\n\n/**\n * Determine if a schema `type` is, or contains, a specific discriminator.\n *\n */\nexport function hasSchemaType(\n  schema: SchemaObject,\n  discriminator: 'array' | 'object' | 'string' | 'number' | 'boolean' | 'integer' | 'null',\n) {\n  if (Array.isArray(schema.type)) {\n    return schema.type.includes(discriminator);\n  }\n\n  return schema.type === discriminator;\n}\n\n/**\n * Because some request body schema shapes might not always be a top-level `properties`, instead\n * nesting it in an `oneOf` or `anyOf` we need to extract the first usable schema that we have. If\n * we don't do this then these non-conventional request body schema payloads may not be properly\n * represented in the HAR that we generate.\n *\n */\nexport function getSafeRequestBody(obj: any) {\n  if ('oneOf' in obj) {\n    return getSafeRequestBody(obj.oneOf[0]);\n  } else if ('anyOf' in obj) {\n    return getSafeRequestBody(obj.anyOf[0]);\n  }\n\n  return obj;\n}\n\ninterface Options {\n  parentIsArray?: boolean;\n  parentKey?: string;\n  payload: unknown;\n}\n\nfunction getSubschemas(schema: any, opts: Options) {\n  let subSchemaDataSize = 0;\n  if (opts.parentIsArray) {\n    // If we don't have data for this parent schema in our body payload then we\n    // shouldn't bother spidering further into the schema looking for more `format`s\n    // for data that definitely doesn't exist.\n    const parentData = lodashGet(opts.payload, opts.parentKey);\n    if (parentData === undefined || !Array.isArray(parentData)) {\n      return false;\n    }\n\n    subSchemaDataSize = parentData.length;\n  }\n\n  let subschemas: any[] = [];\n  if (subSchemaDataSize > 0) {\n    for (let idx = 0; idx < subSchemaDataSize; idx += 1) {\n      subschemas = subschemas.concat(\n        Object.entries(schema).map(([key, subschema]: [string, JSONSchema]) => ({\n          key: opts.parentKey ? [opts.parentKey, idx, key].join('.') : key,\n          schema: getSafeRequestBody(subschema),\n        })),\n      );\n    }\n  } else {\n    subschemas = Object.entries(schema).map(([key, subschema]: [string, JSONSchema]) => ({\n      key: opts.parentKey ? [opts.parentKey, key].join('.') : key,\n      schema: getSafeRequestBody(subschema),\n    }));\n  }\n\n  return subschemas;\n}\n\n/**\n * With a supplied JSON Schema object, spider through it for any schemas that may contain specific\n * kind of `format` that also happen to be within the current `requestBody` payload that we're\n * creating a HAR representation for.\n *\n */\nexport function getTypedFormatsInSchema(\n  format: 'json' | 'binary',\n  schema: any,\n  opts: Options,\n): boolean | string | (string | boolean)[] {\n  try {\n    if (schema?.format === format) {\n      if (opts.parentIsArray) {\n        const parentData = lodashGet(opts.payload, opts.parentKey);\n        if (parentData !== undefined && Array.isArray(parentData)) {\n          return Object.keys(parentData)\n            .map(pdk => {\n              const currentKey = [opts.parentKey, pdk].join('.');\n              if (lodashGet(opts.payload, currentKey) !== undefined) {\n                return currentKey;\n              }\n\n              return false;\n            })\n            .filter(Boolean);\n        }\n      } else if (opts.parentKey && lodashGet(opts.payload, opts.parentKey) !== undefined) {\n        return opts.parentKey;\n      } else if (opts.payload !== undefined) {\n        // If this payload is present and we're looking for a specific format then we should assume\n        // that the **root** schema of the request body is that format, and we aren't trafficking in\n        // a nested object or array schema.\n        return true;\n      }\n\n      return false;\n    }\n\n    const subschemas = getSubschemas(schema, opts);\n    if (!subschemas) {\n      return false;\n    }\n\n    return subschemas\n      .map(({ key, schema: subschema }) => {\n        if ('properties' in subschema) {\n          return getTypedFormatsInSchema(format, subschema.properties, { payload: opts.payload, parentKey: key });\n        } else if ('items' in subschema) {\n          if ((subschema.items as JSONSchema)?.properties) {\n            return getTypedFormatsInSchema(format, (subschema.items as JSONSchema).properties, {\n              payload: opts.payload,\n              parentKey: key,\n              parentIsArray: true,\n            });\n          }\n\n          return getTypedFormatsInSchema(format, subschema.items, {\n            payload: opts.payload,\n            parentKey: key,\n            parentIsArray: true,\n          });\n        }\n\n        // If this schema has neither `properties` or `items` then it's a regular schema\n        // we can re-run.\n        return getTypedFormatsInSchema(format, subschema, { payload: opts.payload, parentKey: key });\n      })\n      .flat()\n      .filter(Boolean);\n  } catch (err) {\n    // If this fails for whatever reason then we should act as if we didn't find any `format`'d\n    // schemas.\n    return [];\n  }\n}\n"]}