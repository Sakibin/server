"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkV2WHK4KJcjs = require('./chunk-V2WHK4KJ.cjs');

// src/index.ts
var _dataurls = require('@readme/data-urls');
var _lodashget = require('lodash.get'); var _lodashget2 = _interopRequireDefault(_lodashget);
var _lodashset = require('lodash.set'); var _lodashset2 = _interopRequireDefault(_lodashset);
var _extensions = require('oas/extensions');
var _operation = require('oas/operation');
var _types = require('oas/types');
var _utils = require('oas/utils');
var _removeundefinedobjects = require('remove-undefined-objects'); var _removeundefinedobjects2 = _interopRequireDefault(_removeundefinedobjects);

// src/lib/style-formatting/index.ts
var _qs = require('qs'); var _qs2 = _interopRequireDefault(_qs);

// src/lib/style-formatting/style-serializer.ts
var isRfc3986Reserved = (char) => ":/?#[]@!$&'()*+,;=".indexOf(char) > -1;
var isRfc3986Unreserved = (char) => /^[a-z0-9\-._~]+$/i.test(char);
function isURIEncoded(value) {
  try {
    return decodeURIComponent(value) !== value;
  } catch (err) {
    return false;
  }
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function encodeDisallowedCharacters(str, {
  escape,
  returnIfEncoded = false,
  isAllowedReserved
} = {}, parse) {
  if (typeof str === "number") {
    str = str.toString();
  }
  if (returnIfEncoded) {
    if (isURIEncoded(str)) {
      return str;
    }
  }
  if (typeof str !== "string" || !str.length) {
    return str;
  }
  if (!escape) {
    return str;
  }
  if (parse) {
    return JSON.parse(str);
  }
  return [...str].map((char) => {
    if (isRfc3986Unreserved(char)) {
      return char;
    }
    if (isRfc3986Reserved(char) && (escape === "unsafe" || isAllowedReserved)) {
      return char;
    }
    const encoder = new TextEncoder();
    const encoded = Array.from(encoder.encode(char)).map((byte) => `0${byte.toString(16).toUpperCase()}`.slice(-2)).map((encodedByte) => `%${encodedByte}`).join("");
    return encoded;
  }).join("");
}
function stylize(config) {
  const { value } = config;
  if (Array.isArray(value)) {
    return encodeArray(config);
  }
  if (isObject(value)) {
    return encodeObject(config);
  }
  return encodePrimitive(config);
}
function encodeArray({
  location,
  key,
  value,
  style,
  explode,
  escape,
  isAllowedReserved = false
}) {
  const valueEncoder = (str) => encodeDisallowedCharacters(str, {
    escape,
    returnIfEncoded: location === "query",
    isAllowedReserved
  });
  switch (style) {
    case "simple":
      return value.map((val) => valueEncoder(val)).join(",");
    case "label":
      return `.${value.map((val) => valueEncoder(val)).join(".")}`;
    case "matrix":
      return value.map((val) => valueEncoder(val)).reduce((prev, curr) => {
        if (!prev || explode) {
          return `${prev || ""};${key}=${curr}`;
        }
        return `${prev},${curr}`;
      }, "");
    case "form":
      return value.map((val) => valueEncoder(val)).join(explode ? `&${key}=` : ",");
    case "spaceDelimited":
      return value.map((val) => valueEncoder(val)).join(` ${explode ? `${key}=` : ""}`);
    case "pipeDelimited":
      return value.map((val) => valueEncoder(val)).join(`|${explode ? `${key}=` : ""}`);
    default:
      return void 0;
  }
}
function encodeObject({ location, key, value, style, explode, escape, isAllowedReserved = false }) {
  const valueEncoder = (str) => encodeDisallowedCharacters(str, {
    escape,
    returnIfEncoded: location === "query",
    isAllowedReserved
  });
  const valueKeys = Object.keys(value);
  switch (style) {
    case "simple":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const middleChar = explode ? "=" : ",";
        const prefix = prev ? `${prev},` : "";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    case "label":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const middleChar = explode ? "=" : ".";
        const prefix = prev ? `${prev}.` : ".";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    case "matrix":
      if (explode) {
        return valueKeys.reduce((prev, curr) => {
          const val = valueEncoder(value[curr]);
          const prefix = prev ? `${prev};` : ";";
          return `${prefix}${curr}=${val}`;
        }, "");
      }
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev},` : `;${key}=`;
        return `${prefix}${curr},${val}`;
      }, "");
    case "form":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev}${explode ? "&" : ","}` : "";
        const separator = explode ? "=" : ",";
        return `${prefix}${curr}${separator}${val}`;
      }, "");
    case "spaceDelimited":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev} ` : "";
        return `${prefix}${curr} ${val}`;
      }, "");
    case "pipeDelimited":
      return valueKeys.reduce((prev, curr) => {
        const val = valueEncoder(value[curr]);
        const prefix = prev ? `${prev}|` : "";
        return `${prefix}${curr}|${val}`;
      }, "");
    case "deepObject":
      return valueKeys.reduce((curr) => {
        const val = valueEncoder(value[curr]);
        return `${val}`;
      }, "");
    default:
      return void 0;
  }
}
function encodePrimitive({ location, key, value, style, escape, isAllowedReserved = false }) {
  const valueEncoder = (str) => encodeDisallowedCharacters(str, {
    escape,
    returnIfEncoded: location === "query" || location === "body",
    isAllowedReserved
  });
  switch (style) {
    case "simple":
      return valueEncoder(value);
    case "label":
      return `.${valueEncoder(value)}`;
    case "matrix":
      if (value === "") {
        return `;${key}`;
      }
      return `;${key}=${valueEncoder(value)}`;
    case "form":
      return valueEncoder(value);
    case "deepObject":
      return valueEncoder(value);
    default:
      return void 0;
  }
}

// src/lib/style-formatting/index.ts
function shouldNotStyleEmptyValues(parameter) {
  return ["simple", "spaceDelimited", "pipeDelimited", "deepObject"].includes(parameter.style);
}
function shouldNotStyleReservedHeader(parameter) {
  return ["accept", "authorization", "content-type"].includes(parameter.name.toLowerCase());
}
function removeUndefinedForPath(value) {
  let finalValue = value;
  if (typeof finalValue === "undefined") {
    return "";
  }
  if (Array.isArray(finalValue)) {
    finalValue = finalValue.filter((val) => val === void 0 ? "" : val);
    if (finalValue.length === 0) {
      finalValue = "";
    }
  }
  if (typeof finalValue === "object") {
    Object.keys(finalValue).forEach((key) => {
      finalValue[key] = finalValue[key] === void 0 ? "" : finalValue[key];
    });
  }
  return finalValue;
}
function stylizeValue(value, parameter) {
  let finalValue = value;
  if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === "undefined" || finalValue === "")) {
    if (parameter.in === "path") {
      return "";
    }
    return void 0;
  }
  if (parameter.in === "path") {
    finalValue = removeUndefinedForPath(finalValue);
  }
  if (parameter.in === "header" && shouldNotStyleReservedHeader(parameter)) {
    return value;
  }
  let style = parameter.style;
  if (!style) {
    if (parameter.in === "query") {
      style = "form";
    } else if (parameter.in === "path") {
      style = "simple";
    } else if (parameter.in === "header") {
      style = "simple";
    } else if (parameter.in === "cookie") {
      style = "form";
    }
  }
  let explode = parameter.explode;
  if (explode === void 0 && style === "form") {
    explode = true;
  }
  return stylize({
    location: parameter.in,
    value: finalValue,
    key: parameter.name,
    style,
    explode,
    /**
     * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or "unsafe".
     *  I do not know if it is correct for query to use this. See style-serializer for more info
     */
    escape: true,
    ...parameter.in === "query" ? { isAllowedReserved: parameter.allowReserved || false } : {}
  });
}
function handleDeepObject(value, parameter) {
  return _qs2.default.stringify(value, {
    // eslint-disable-next-line consistent-return
    encoder(str, defaultEncoder, charset, type) {
      if (type === "key") {
        const prefixedKey = str.split(/[[\]]/g).filter(Boolean).map((k) => `[${k}]`).join("");
        return `${parameter.name}${prefixedKey}`;
      } else if (type === "value") {
        return stylizeValue(str, parameter);
      }
    }
  }).split("&").map((item) => {
    const split = item.split("=");
    return {
      label: split[0],
      // `qs` will coerce null values into being `undefined` string but we want to preserve them.
      value: split[1] === "undefined" ? null : split[1]
    };
  });
}
function handleExplode(value, parameter) {
  if (Array.isArray(value) && _optionalChain([parameter, 'access', _ => _.schema, 'optionalAccess', _2 => _2.type]) === "array" && parameter.style === "deepObject") {
    const newObj = {};
    const deepObjs = handleDeepObject(value, parameter);
    deepObjs.forEach((obj) => {
      newObj[obj.label] = obj.value;
    });
    return newObj;
  }
  if (Array.isArray(value)) {
    return value.map((val) => {
      return stylizeValue(val, parameter);
    });
  }
  if (typeof value === "object" && value !== null) {
    const newObj = {};
    Object.keys(value).forEach((key) => {
      if (parameter.style === "deepObject") {
        const deepObjs = handleDeepObject(value, parameter);
        deepObjs.forEach((obj) => {
          newObj[obj.label] = obj.value;
        });
      } else {
        newObj[key] = stylizeValue(value[key], parameter);
      }
    });
    return newObj;
  }
  return stylizeValue(value, parameter);
}
function shouldExplode(parameter) {
  return (parameter.explode || parameter.explode !== false && parameter.style === "form" || // style: deepObject && explode: false doesn't exist so explode it always
  // https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples
  parameter.style === "deepObject") && // header and path doesn't explode into separate parameters like query and cookie do
  parameter.in !== "header" && parameter.in !== "path";
}
function formatStyle(value, parameter) {
  if (parameter.style === "deepObject" && (!value || typeof value !== "object" || parameter.explode === false)) {
    return void 0;
  }
  if (shouldExplode(parameter)) {
    return handleExplode(value, parameter);
  }
  return stylizeValue(value, parameter);
}

// src/lib/utils.ts

function hasSchemaType(schema, discriminator) {
  if (Array.isArray(schema.type)) {
    return schema.type.includes(discriminator);
  }
  return schema.type === discriminator;
}
function getSafeRequestBody(obj) {
  if ("oneOf" in obj) {
    return getSafeRequestBody(obj.oneOf[0]);
  } else if ("anyOf" in obj) {
    return getSafeRequestBody(obj.anyOf[0]);
  }
  return obj;
}
function getSubschemas(schema, opts) {
  let subSchemaDataSize = 0;
  if (opts.parentIsArray) {
    const parentData = _lodashget2.default.call(void 0, opts.payload, opts.parentKey);
    if (parentData === void 0 || !Array.isArray(parentData)) {
      return false;
    }
    subSchemaDataSize = parentData.length;
  }
  let subschemas = [];
  if (subSchemaDataSize > 0) {
    for (let idx = 0; idx < subSchemaDataSize; idx += 1) {
      subschemas = subschemas.concat(
        Object.entries(schema).map(([key, subschema]) => ({
          key: opts.parentKey ? [opts.parentKey, idx, key].join(".") : key,
          schema: getSafeRequestBody(subschema)
        }))
      );
    }
  } else {
    subschemas = Object.entries(schema).map(([key, subschema]) => ({
      key: opts.parentKey ? [opts.parentKey, key].join(".") : key,
      schema: getSafeRequestBody(subschema)
    }));
  }
  return subschemas;
}
function getTypedFormatsInSchema(format, schema, opts) {
  try {
    if (_optionalChain([schema, 'optionalAccess', _3 => _3.format]) === format) {
      if (opts.parentIsArray) {
        const parentData = _lodashget2.default.call(void 0, opts.payload, opts.parentKey);
        if (parentData !== void 0 && Array.isArray(parentData)) {
          return Object.keys(parentData).map((pdk) => {
            const currentKey = [opts.parentKey, pdk].join(".");
            if (_lodashget2.default.call(void 0, opts.payload, currentKey) !== void 0) {
              return currentKey;
            }
            return false;
          }).filter(Boolean);
        }
      } else if (opts.parentKey && _lodashget2.default.call(void 0, opts.payload, opts.parentKey) !== void 0) {
        return opts.parentKey;
      } else if (opts.payload !== void 0) {
        return true;
      }
      return false;
    }
    const subschemas = getSubschemas(schema, opts);
    if (!subschemas) {
      return false;
    }
    return subschemas.map(({ key, schema: subschema }) => {
      if ("properties" in subschema) {
        return getTypedFormatsInSchema(format, subschema.properties, { payload: opts.payload, parentKey: key });
      } else if ("items" in subschema) {
        if (_optionalChain([subschema, 'access', _4 => _4.items, 'optionalAccess', _5 => _5.properties])) {
          return getTypedFormatsInSchema(format, subschema.items.properties, {
            payload: opts.payload,
            parentKey: key,
            parentIsArray: true
          });
        }
        return getTypedFormatsInSchema(format, subschema.items, {
          payload: opts.payload,
          parentKey: key,
          parentIsArray: true
        });
      }
      return getTypedFormatsInSchema(format, subschema, { payload: opts.payload, parentKey: key });
    }).flat().filter(Boolean);
  } catch (err) {
    return [];
  }
}

// src/index.ts
function formatter(values, param, type, onlyIfExists = false) {
  if (param.style) {
    const value2 = values[type][param.name];
    return formatStyle(value2, param);
  }
  let value;
  if (typeof values[type][param.name] !== "undefined") {
    value = values[type][param.name];
  } else if (onlyIfExists && !param.required) {
    value = void 0;
  } else if (param.required && param.schema && !_types.isRef.call(void 0, param.schema) && param.schema.default) {
    value = param.schema.default;
  } else if (type === "path") {
    return param.name;
  }
  if (param.schema && !_types.isRef.call(void 0, param.schema) && param.schema.type === "array" && param.schema.items && !_types.isRef.call(void 0, param.schema.items) && param.schema.items.format === "binary") {
    if (Array.isArray(value)) {
      return value;
    }
    return JSON.stringify(value);
  }
  if (value !== void 0) {
    if (type === "query") {
      return formatStyle(value, param);
    }
    return value;
  }
  return void 0;
}
function multipartBodyToFormatterParams(payload, oasMediaTypeObject, schema) {
  const encoding = oasMediaTypeObject.encoding;
  if (typeof payload === "object" && payload !== null) {
    return Object.keys(payload).map((key) => {
      if (!schema.properties[key]) {
        return false;
      }
      const paramEncoding = encoding ? encoding[key] : void 0;
      return {
        name: key,
        // If the style isn't defined, use the default
        style: paramEncoding ? paramEncoding.style : void 0,
        // If explode isn't defined, use the default
        explode: paramEncoding ? paramEncoding.explode : void 0,
        required: schema.required && typeof schema.required === "boolean" && Boolean(schema.required) || Array.isArray(schema.required) && schema.required.includes(key),
        schema: schema.properties[key],
        in: "body"
      };
    }).filter(Boolean);
  }
  return [];
}
var defaultFormDataTypes = Object.keys(_utils.jsonSchemaTypes).reduce((prev, curr) => {
  return Object.assign(prev, { [curr]: {} });
}, {});
function getResponseContentType(content) {
  const types = Object.keys(content) || [];
  if (types && types.length) {
    const jsonType = types.find((t) => _utils.matchesMimeType.json(t));
    if (jsonType) {
      return jsonType;
    }
    return types[0];
  }
  return "application/json";
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}
function stringify(json) {
  return JSON.stringify(_removeundefinedobjects2.default.call(void 0, typeof json.RAW_BODY !== "undefined" ? json.RAW_BODY : json));
}
function stringifyParameter(param) {
  if (param === null || isPrimitive(param)) {
    return param;
  } else if (Array.isArray(param) && param.every(isPrimitive)) {
    return String(param);
  }
  return JSON.stringify(param);
}
function appendHarValue(harParam, name, value, addtlData = {}) {
  if (typeof value === "undefined")
    return;
  if (Array.isArray(value)) {
    value.forEach((singleValue) => {
      appendHarValue(harParam, name, singleValue);
    });
  } else if (typeof value === "object" && value !== null) {
    Object.keys(value).forEach((key) => {
      appendHarValue(harParam, key, value[key]);
    });
  } else {
    harParam.push({
      ...addtlData,
      name,
      value: String(value)
    });
  }
}
function encodeBodyForHAR(body) {
  if (isPrimitive(body)) {
    return body;
  } else if (typeof body === "object" && body !== null && !Array.isArray(body) && typeof body.RAW_BODY !== "undefined") {
    if (isPrimitive(body.RAW_BODY)) {
      return body.RAW_BODY;
    }
    return stringify(body.RAW_BODY);
  }
  return stringify(body);
}
function oasToHar(oas, operationSchema, values = {}, auth = {}, opts = {
  // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in
  // order to funnel requests through our CORS-friendly proxy.
  proxyUrl: false
}) {
  let operation;
  if (!operationSchema || typeof operationSchema.getParameters !== "function") {
    operation = new (0, _operation.Operation)(
      oas,
      _optionalChain([operationSchema, 'optionalAccess', _6 => _6.path]) || "",
      _optionalChain([operationSchema, 'optionalAccess', _7 => _7.method]) || "",
      operationSchema || { path: "", method: "" }
    );
  } else {
    operation = operationSchema;
  }
  const apiDefinition = oas.getDefinition();
  const formData = {
    ...defaultFormDataTypes,
    server: {
      selected: 0,
      variables: oas.defaultVariables(0)
    },
    ...values
  };
  formData.server.variables = {
    ...oas.defaultVariables(formData.server.selected),
    ...formData.server.variables ? formData.server.variables : {}
  };
  const har = {
    cookies: [],
    headers: [],
    headersSize: 0,
    queryString: [],
    // @ts-expect-error This is fine because we're fleshing `postData` out further down.
    postData: {},
    bodySize: 0,
    method: operation.method.toUpperCase(),
    url: `${oas.url(formData.server.selected, formData.server.variables)}${operation.path}`.replace(/\s/g, "%20"),
    httpVersion: "HTTP/1.1"
  };
  if (opts.proxyUrl) {
    if (oas.getExtension(_extensions.PROXY_ENABLED, operation)) {
      har.url = `https://try.readme.io/${har.url}`;
    }
  }
  const parameters = operation.getParameters();
  har.url = har.url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, (full, key) => {
    if (!operation || !parameters)
      return key;
    const parameter = parameters.find((param) => param.name === key) || { name: key };
    if (!("style" in parameter) || !parameter.style) {
      return encodeURIComponent(formatter(formData, parameter, "path"));
    }
    return formatter(formData, parameter, "path");
  });
  const queryStrings = parameters && parameters.filter((param) => param.in === "query");
  if (queryStrings && queryStrings.length) {
    queryStrings.forEach((queryString) => {
      const value = formatter(formData, queryString, "query", true);
      appendHarValue(har.queryString, queryString.name, value);
    });
  }
  const cookies = parameters && parameters.filter((param) => param.in === "cookie");
  if (cookies && cookies.length) {
    cookies.forEach((cookie) => {
      const value = formatter(formData, cookie, "cookie", true);
      appendHarValue(har.cookies, cookie.name, value);
    });
  }
  if (operation.schema.responses) {
    Object.keys(operation.schema.responses).some((response) => {
      if (_types.isRef.call(void 0, operation.schema.responses[response]))
        return false;
      const content = operation.schema.responses[response].content;
      if (!content)
        return false;
      if (Object.keys(formData.header).find((h) => h.toLowerCase() === "accept"))
        return true;
      har.headers.push({
        name: "accept",
        value: getResponseContentType(content)
      });
      return true;
    });
  }
  let hasContentType = false;
  let contentType = operation.getContentType();
  const headers = parameters && parameters.filter((param) => param.in === "header");
  if (headers && headers.length) {
    headers.forEach((header) => {
      const value = formatter(formData, header, "header", true);
      if (typeof value === "undefined")
        return;
      if (header.name.toLowerCase() === "content-type") {
        hasContentType = true;
        contentType = String(value);
      }
      appendHarValue(har.headers, header.name, value);
    });
  }
  const userDefinedHeaders = oas.getExtension(_extensions.HEADERS, operation);
  if (userDefinedHeaders) {
    userDefinedHeaders.forEach((header) => {
      if (typeof header.key === "string" && header.key.toLowerCase() === "content-type") {
        hasContentType = true;
        contentType = String(header.value);
      }
      har.headers.push({
        name: String(header.key),
        value: String(header.value)
      });
    });
  }
  if (formData.header) {
    const acceptHeader = Object.keys(formData.header).find((h) => h.toLowerCase() === "accept");
    if (acceptHeader && !har.headers.find((hdr) => hdr.name.toLowerCase() === "accept")) {
      har.headers.push({
        name: "accept",
        value: String(formData.header[acceptHeader])
      });
    }
    const authorizationHeader = Object.keys(formData.header).find((h) => h.toLowerCase() === "authorization");
    if (authorizationHeader && !har.headers.find((hdr) => hdr.name.toLowerCase() === "authorization")) {
      har.headers.push({
        name: "authorization",
        value: String(formData.header[authorizationHeader])
      });
    }
  }
  let requestBody;
  if (operation.hasRequestBody()) {
    requestBody = operation.getParametersAsJSONSchema().find((payload) => {
      return payload.type === (operation.isFormUrlEncoded() ? "formData" : "body");
    });
  }
  if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {
    const requestBodySchema = requestBody.schema;
    if (operation.isFormUrlEncoded()) {
      if (Object.keys(formData.formData).length) {
        const cleanFormData = _removeundefinedobjects2.default.call(void 0, JSON.parse(JSON.stringify(formData.formData)));
        if (cleanFormData !== void 0) {
          har.postData.params = [];
          har.postData.mimeType = "application/x-www-form-urlencoded";
          Object.keys(cleanFormData).forEach((name) => {
            har.postData.params.push({
              name,
              value: stringifyParameter(cleanFormData[name])
            });
          });
        }
      }
    } else if ("body" in formData && formData.body !== void 0 && (isPrimitive(formData.body) || Object.keys(formData.body).length)) {
      const isMultipart = operation.isMultipart();
      const isJSON = operation.isJson();
      if (isMultipart || isJSON) {
        try {
          let cleanBody = _removeundefinedobjects2.default.call(void 0, JSON.parse(JSON.stringify(formData.body)));
          if (isMultipart) {
            har.postData.mimeType = "multipart/form-data";
            har.postData.params = [];
            const safeBodySchema = getSafeRequestBody(requestBodySchema);
            const binaryTypes = Object.keys(safeBodySchema.properties).filter((key) => {
              const propData = safeBodySchema.properties[key];
              if (propData.format === "binary") {
                return true;
              } else if (propData.type === "array" && propData.items && typeof propData.items === "object" && propData.items !== null && propData.items.format === "binary") {
                return true;
              }
              return false;
            });
            if (cleanBody !== void 0) {
              const multipartParams = multipartBodyToFormatterParams(
                formData.body,
                operation.schema.requestBody.content["multipart/form-data"],
                safeBodySchema
              );
              if (multipartParams.length) {
                Object.keys(cleanBody).forEach((name) => {
                  const param = multipartParams.find((multipartParam) => multipartParam.name === name);
                  const addtlData = {};
                  let value = formatter(formData, param, "body", true);
                  if (!Array.isArray(value)) {
                    value = [value];
                  }
                  value.forEach((val) => {
                    if (binaryTypes.includes(name)) {
                      const parsed = _dataurls.parse.call(void 0, val);
                      if (parsed) {
                        addtlData.fileName = "name" in parsed ? parsed.name : "unknown";
                        if ("contentType" in parsed) {
                          addtlData.contentType = parsed.contentType;
                        }
                      }
                    }
                    appendHarValue(har.postData.params, name, val, addtlData);
                  });
                });
              }
            }
          } else {
            har.postData.mimeType = contentType;
            if (hasSchemaType(requestBody.schema, "string") || hasSchemaType(requestBody.schema, "integer") || hasSchemaType(requestBody.schema, "number") || hasSchemaType(requestBody.schema, "boolean")) {
              har.postData.text = JSON.stringify(JSON.parse(cleanBody));
            } else {
              const jsonTypes = getTypedFormatsInSchema("json", requestBodySchema.properties, { payload: cleanBody });
              if (Array.isArray(jsonTypes) && jsonTypes.length) {
                try {
                  jsonTypes.forEach((prop) => {
                    try {
                      _lodashset2.default.call(void 0, cleanBody, prop, JSON.parse(_lodashget2.default.call(void 0, cleanBody, prop)));
                    } catch (e) {
                    }
                  });
                  if (typeof cleanBody.RAW_BODY !== "undefined") {
                    cleanBody = cleanBody.RAW_BODY;
                  }
                  har.postData.text = JSON.stringify(cleanBody);
                } catch (e) {
                  har.postData.text = stringify(formData.body);
                }
              } else {
                har.postData.text = encodeBodyForHAR(formData.body);
              }
            }
          }
        } catch (e) {
          har.postData.text = stringify(formData.body);
        }
      } else {
        har.postData.mimeType = contentType;
        har.postData.text = encodeBodyForHAR(formData.body);
      }
    }
  }
  if ((har.postData.text || requestBody && requestBody.schema && Object.keys(requestBody.schema).length) && !hasContentType) {
    har.headers.push({
      name: "content-type",
      value: contentType
    });
  }
  const securityRequirements = operation.getSecurity();
  if (securityRequirements && securityRequirements.length) {
    securityRequirements.forEach((schemes) => {
      Object.keys(schemes).forEach((security) => {
        const securityValue = _chunkV2WHK4KJcjs.configureSecurity.call(void 0, apiDefinition, auth, security);
        if (!securityValue) {
          return;
        }
        if (securityValue.value.name === "authorization") {
          if (har[securityValue.type].find((v) => v.name === securityValue.value.name)) {
            return;
          }
        }
        if (har[securityValue.type].find(
          (v) => v.name === securityValue.value.name && v.value === securityValue.value.value
        )) {
          return;
        }
        har[securityValue.type].push(securityValue.value);
      });
    });
  }
  if (Object.keys(har.postData).length === 0) {
    delete har.postData;
  }
  return {
    log: {
      entries: [
        {
          request: har
        }
      ]
    }
  };
}


exports.default = oasToHar;
/**
 * This file has been extracted and modified from `swagger-client`.
 *
 * @license Apache 2.0
 * @link https://npm.im/swagger-client
 * @link https://github.com/swagger-api/swagger-js/blob/master/src/execute/oas3/style-serializer.js
 */

module.exports = exports.default//# sourceMappingURL=index.cjs.map