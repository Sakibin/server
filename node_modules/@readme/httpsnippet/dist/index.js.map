{"version":3,"sources":["../src/index.ts","../src/helpers/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReducedHelperObject } from './helpers/reducer.js';\nimport type { ClientId, TargetId } from './targets/index.js';\nimport type { Param, PostDataCommon, Request as NpmHarRequest } from 'har-format';\nimport type { UrlWithParsedQuery } from 'node:url';\n\nimport { format as urlFormat, parse as urlParse } from 'node:url';\n\nimport formDataToString from 'formdata-to-string';\nimport { stringify as queryStringify } from 'qs';\n\nimport { getHeaderName } from './helpers/headers.js';\nimport { reducer } from './helpers/reducer.js';\nimport { targets } from './targets/index.js';\n\nexport { availableTargets, extname } from './helpers/utils.js';\nexport { addTarget, addTargetClient, addClientPlugin } from './targets/index.js';\n\n/** is this wrong?  yes.  according to the spec (http://www.softwareishard.com/blog/har-12-spec/#postData) it's technically wrong since `params` and `text` are (by the spec) mutually exclusive.  However, in practice, this is not what is often the case.\n *\n * In general, this library takes a _descriptive_ rather than _perscriptive_ approach (see https://amyrey.web.unc.edu/classes/ling-101-online/tutorials/understanding-prescriptive-vs-descriptive-grammar/).\n *\n * Then, in addition to that, it really adds to complexity with TypeScript (TypeScript takes this constraint very very seriously) in a way that's not actually super useful.  So, we treat this object as though it could have both or either of `params` and/or `text`.\n */\ntype PostDataBase = PostDataCommon & {\n  params?: Param[];\n  text?: string;\n};\n\nexport type HarRequest = Omit<NpmHarRequest, 'postData'> & { postData: PostDataBase };\n\nexport interface RequestExtras {\n  allHeaders: ReducedHelperObject;\n  cookiesObj: ReducedHelperObject;\n  fullUrl: string;\n  headersObj: ReducedHelperObject;\n  postData: PostDataBase & {\n    boundary?: string;\n    jsonObj?: ReducedHelperObject;\n    paramsObj?: ReducedHelperObject;\n  };\n  queryObj: ReducedHelperObject;\n  uriObj: UrlWithParsedQuery;\n}\n\nexport type Request = HarRequest & RequestExtras;\n\ninterface Entry {\n  request: Partial<HarRequest>;\n}\n\ninterface HarEntry {\n  log: {\n    creator: {\n      name: string;\n      version: string;\n    };\n    entries: Entry[];\n    version: string;\n  };\n}\n\nexport interface HTTPSnippetOptions {\n  harIsAlreadyEncoded?: boolean;\n}\n\nconst isHarEntry = (value: any): value is HarEntry =>\n  typeof value === 'object' &&\n  'log' in value &&\n  typeof value.log === 'object' &&\n  'entries' in value.log &&\n  Array.isArray(value.log.entries);\n\nexport class HTTPSnippet {\n  initCalled = false;\n\n  entries: Entry[] = [];\n\n  requests: Request[] = [];\n\n  options: HTTPSnippetOptions = {};\n\n  constructor(input: HarEntry | HarRequest, opts: HTTPSnippetOptions = {}) {\n    this.options = {\n      harIsAlreadyEncoded: false,\n      ...opts,\n    };\n\n    // prep the main container\n    this.requests = [];\n\n    // is it har?\n    if (isHarEntry(input)) {\n      this.entries = input.log.entries;\n    } else {\n      this.entries = [\n        {\n          request: input,\n        },\n      ];\n    }\n  }\n\n  async init() {\n    this.initCalled = true;\n\n    const promises: Promise<Request>[] = [];\n\n    this.entries.forEach(({ request }) => {\n      // add optional properties to make validation successful\n      const req = {\n        bodySize: 0,\n        headersSize: 0,\n        headers: [],\n        cookies: [],\n        httpVersion: 'HTTP/1.1',\n        queryString: [],\n        postData: {\n          mimeType: request.postData?.mimeType || 'application/octet-stream',\n        },\n        ...request,\n      };\n\n      // Per the HAR spec `mimeType` needs to always be present if we have a `postData` object.\n      if (req.postData && !req.postData.mimeType) {\n        req.postData.mimeType = 'application/octet-stream';\n      }\n\n      promises.push(this.prepare(req as HarRequest, this.options));\n    });\n\n    this.requests = await Promise.all(promises);\n\n    return this;\n  }\n\n  async prepare(harRequest: HarRequest, options: HTTPSnippetOptions) {\n    const request: Request = {\n      ...harRequest,\n      fullUrl: '',\n      uriObj: {} as UrlWithParsedQuery,\n      queryObj: {},\n      headersObj: {},\n      cookiesObj: {},\n      allHeaders: {},\n    };\n\n    // construct query objects\n    if (request.queryString && request.queryString.length) {\n      request.queryObj = request.queryString.reduce(reducer, {});\n    }\n\n    // construct headers objects\n    if (request.headers && request.headers.length) {\n      const http2VersionRegex = /^HTTP\\/2/;\n      request.headersObj = request.headers.reduce((accumulator, { name, value }) => {\n        const headerName = http2VersionRegex.exec(request.httpVersion) ? name.toLocaleLowerCase() : name;\n        return {\n          ...accumulator,\n          [headerName]: value,\n        };\n      }, {});\n    }\n\n    // construct headers objects\n    if (request.cookies && request.cookies.length) {\n      request.cookiesObj = request.cookies.reduceRight(\n        (accumulator, { name, value }) => ({\n          ...accumulator,\n          [name]: value,\n        }),\n        {},\n      );\n    }\n\n    // construct Cookie header\n    const cookies = request.cookies?.map(({ name, value }) => {\n      if (options.harIsAlreadyEncoded) {\n        return `${name}=${value}`;\n      }\n\n      return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n    });\n\n    if (cookies?.length) {\n      request.allHeaders.cookie = cookies.join('; ');\n    }\n\n    switch (request.postData.mimeType) {\n      case 'multipart/mixed':\n      case 'multipart/related':\n      case 'multipart/form-data':\n      case 'multipart/alternative':\n        // reset values\n        request.postData.text = '';\n        request.postData.mimeType = 'multipart/form-data';\n\n        if (request.postData?.params) {\n          const form = new FormData();\n\n          request.postData?.params.forEach(param => {\n            const name = param.name;\n            const value = param.value || '';\n            const filename = param.fileName || null;\n            const contentType = param.contentType || '';\n\n            if (filename) {\n              form.append(name, new Blob([value], { type: contentType }), filename);\n            } else {\n              form.append(name, value);\n            }\n          });\n\n          const boundary = '---011000010111000001101001'; // this is binary for \"api\" (easter egg)\n          request.postData.boundary = boundary;\n          request.postData.text = await formDataToString(form, { boundary });\n\n          // Since headers are case-sensitive we need to see if there's an existing `Content-Type` header that we can override.\n          const contentTypeHeader = getHeaderName(request.headersObj, 'content-type') || 'content-type';\n\n          request.headersObj[contentTypeHeader] = `multipart/form-data; boundary=${boundary}`;\n        }\n        break;\n\n      case 'application/x-www-form-urlencoded':\n        if (!request.postData.params) {\n          request.postData.text = '';\n        } else {\n          // @ts-expect-error the `har-format` types make this challenging\n          request.postData.paramsObj = request.postData.params.reduce(reducer, {});\n\n          // always overwrite\n          request.postData.text = queryStringify(request.postData.paramsObj);\n        }\n        break;\n\n      case 'text/json':\n      case 'text/x-json':\n      case 'application/json':\n      case 'application/x-json':\n        request.postData.mimeType = 'application/json';\n\n        if (request.postData.text) {\n          try {\n            request.postData.jsonObj = JSON.parse(request.postData.text);\n          } catch (e) {\n            // force back to `text/plain` if headers have proper content-type value, then this should also work\n            request.postData.mimeType = 'text/plain';\n          }\n        }\n        break;\n    }\n\n    // create allHeaders object\n    const allHeaders = {\n      ...request.allHeaders,\n      ...request.headersObj,\n    };\n\n    const urlWithParsedQuery = urlParse(request.url, true, true); //?\n\n    // query string key/value pairs in with literal querystrings containd within the url\n    request.queryObj = {\n      ...request.queryObj,\n      ...(urlWithParsedQuery.query as ReducedHelperObject),\n    }; //?\n\n    // reset uriObj values for a clean url\n    let search;\n    if (options.harIsAlreadyEncoded) {\n      search = queryStringify(request.queryObj, {\n        encode: false,\n        indices: false,\n      });\n    } else {\n      search = queryStringify(request.queryObj, {\n        indices: false,\n      });\n    }\n\n    const uriObj = {\n      ...urlWithParsedQuery,\n      query: request.queryObj,\n      search,\n      path: search ? `${urlWithParsedQuery.pathname}?${search}` : urlWithParsedQuery.pathname,\n    };\n\n    // keep the base url clean of queryString\n    const url = urlFormat({\n      ...urlWithParsedQuery,\n      query: null,\n      search: null,\n    }); //?\n\n    const fullUrl = urlFormat({\n      ...urlWithParsedQuery,\n      ...uriObj,\n    }); //?\n\n    return {\n      ...request,\n      allHeaders,\n      fullUrl,\n      url,\n      uriObj,\n    };\n  }\n\n  async convert(targetId: TargetId, clientId?: ClientId, options?: any) {\n    if (!this.initCalled) {\n      await this.init();\n    }\n\n    if (!options && clientId) {\n      options = clientId;\n    }\n\n    const target = targets[targetId];\n    if (!target) {\n      return false;\n    }\n\n    const { convert } = target.clientsById[clientId || target.info.default];\n    const results = this.requests.map(request => convert(request, options));\n    return results.length === 1 ? results[0] : results;\n  }\n}\n","import type { ClientId, ClientInfo, TargetId, TargetInfo } from '../targets/index.js';\n\nimport { targets } from '../targets/index.js';\n\nexport interface AvailableTarget extends TargetInfo {\n  clients: ClientInfo[];\n}\n\nexport const availableTargets = () =>\n  Object.keys(targets).map<AvailableTarget>(targetId => ({\n    ...targets[targetId as TargetId].info,\n    clients: Object.keys(targets[targetId as TargetId].clientsById).map(\n      clientId => targets[targetId as TargetId].clientsById[clientId].info,\n    ),\n  }));\n\nexport const extname = (targetId: TargetId, clientId: ClientId) => {\n  const target = targets[targetId];\n  if (!target) {\n    return '';\n  }\n\n  return target.clientsById[clientId]?.info.extname || '';\n};\n"]}