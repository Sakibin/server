"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } var _class;

var _chunkNVFSP2R3cjs = require('./chunk-NVFSP2R3.cjs');





var _chunkPGVX6M6Ccjs = require('./chunk-PGVX6M6C.cjs');

// src/index.ts
var _oastohar = require('@readme/oas-to-har'); var _oastohar2 = _interopRequireDefault(_oastohar);
var _fetchhar = require('fetch-har'); var _fetchhar2 = _interopRequireDefault(_fetchhar);
var _oas = require('oas'); var _oas2 = _interopRequireDefault(_oas);
var APICore = (_class = class {
  
  __init() {this.auth = []}
  __init2() {this.server = false}
  __init3() {this.config = {}}
  
  constructor(definition, userAgent) {;_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);
    if (definition)
      this.spec = _oas2.default.init(definition);
    if (userAgent)
      this.userAgent = userAgent;
  }
  setSpec(spec) {
    this.spec = spec;
  }
  setConfig(config) {
    this.config = config;
    return this;
  }
  setUserAgent(userAgent) {
    this.userAgent = userAgent;
    return this;
  }
  setAuth(...values) {
    this.auth = values;
    return this;
  }
  setServer(url, variables = {}) {
    this.server = { url, variables };
    return this;
  }
  async fetch(path, method, body, metadata) {
    const operation = this.spec.operation(path, method);
    return this.fetchOperation(operation, body, metadata);
  }
  /**
   * Retrieve a HAR for a given HTTP request.
   *
   * @internal
   */
  getHARForRequest(operation, data, auth) {
    return _oastohar2.default.call(void 0, this.spec, operation, data, auth);
  }
  async fetchOperation(operation, body, metadata) {
    return _chunkPGVX6M6Ccjs.prepareParams.call(void 0, operation, body, metadata).then((params) => {
      const data = { ...params };
      if (this.server) {
        const preparedServer = _chunkPGVX6M6Ccjs.prepareServer.call(void 0, this.spec, this.server.url, this.server.variables);
        if (preparedServer) {
          data.server = preparedServer;
        }
      }
      const har = this.getHARForRequest(operation, data, _chunkPGVX6M6Ccjs.prepareAuth.call(void 0, this.auth, operation));
      let timeoutSignal;
      const init = {};
      if (this.config.timeout) {
        const controller = new AbortController();
        timeoutSignal = setTimeout(() => controller.abort(), this.config.timeout);
        init.signal = controller.signal;
      }
      return _fetchhar2.default.call(void 0, har, {
        files: data.files || {},
        init,
        userAgent: this.userAgent
      }).then(async (res) => {
        const parsed = await _chunkPGVX6M6Ccjs.parseResponse.call(void 0, res);
        if (res.status >= 400 && res.status <= 599) {
          throw new (0, _chunkNVFSP2R3cjs.FetchError)(
            parsed.status,
            parsed.data,
            parsed.headers,
            parsed.res
          );
        }
        return parsed;
      }).finally(() => {
        if (this.config.timeout) {
          clearTimeout(timeoutSignal);
        }
      });
    });
  }
}, _class);


exports.default = APICore;

module.exports = exports.default;
//# sourceMappingURL=index.cjs.map