{"version":3,"sources":["../src/lib/getJSONSchemaDefaults.ts","../src/lib/parseResponse.ts","../src/lib/prepareAuth.ts","../src/lib/prepareParams.ts","../node_modules/get-stream/source/contents.js","../node_modules/get-stream/source/utils.js","../node_modules/get-stream/source/array-buffer.js","../node_modules/get-stream/source/buffer.js","../src/lib/prepareServer.ts"],"sourcesContent":["import type { SchemaWrapper } from 'oas/operation/get-parameters-as-json-schema';\nimport type { SchemaObject } from 'oas/types';\n\nimport traverse from 'json-schema-traverse';\n\n/**\n * Run through a JSON Schema object and compose up an object containing default data for any schema\n * property that is required and also has a defined default.\n *\n * Code partially adapted from the `json-schema-default` package but modified to only return\n * defaults of required properties.\n *\n * @todo This is a good candidate to be moved into a core `oas` library method.\n * @see {@link https://github.com/mdornseif/json-schema-default}\n */\nexport default function getJSONSchemaDefaults(jsonSchemas: SchemaWrapper[]) {\n  return jsonSchemas\n    .map(({ type: payloadType, schema: jsonSchema }) => {\n      const defaults: Record<string, unknown> = {};\n      traverse(\n        jsonSchema,\n        (\n          schema: SchemaObject,\n          pointer: string,\n          rootSchema: SchemaObject,\n          parentPointer?: string,\n          parentKeyword?: string,\n          parentSchema?: SchemaObject,\n          indexProperty?: string | number,\n        ) => {\n          if (!pointer.startsWith('/properties/')) {\n            return;\n          }\n\n          if (Array.isArray(parentSchema?.required) && parentSchema?.required.includes(String(indexProperty))) {\n            if (schema.type === 'object' && indexProperty) {\n              defaults[indexProperty] = {};\n            }\n\n            let destination = defaults;\n            if (parentPointer) {\n              // To map nested objects correct we need to pick apart the parent pointer.\n              parentPointer\n                .replace(/\\/properties/g, '')\n                .split('/')\n                .forEach((subSchema: string) => {\n                  if (subSchema === '') {\n                    return;\n                  }\n\n                  destination = (destination?.[subSchema] as Record<string, unknown>) || {};\n                });\n            }\n\n            if (schema.default !== undefined) {\n              if (indexProperty !== undefined) {\n                destination[indexProperty] = schema.default;\n              }\n            }\n          }\n        },\n      );\n\n      if (!Object.keys(defaults).length) {\n        return {};\n      }\n\n      return {\n        // @todo should we filter out empty and undefined objects from here with `remove-undefined-objects`?\n        [payloadType]: defaults,\n      };\n    })\n    .reduce((prev, next) => Object.assign(prev, next));\n}\n","import { matchesMimeType } from 'oas/utils';\n\nexport default async function parseResponse<HTTPStatus extends number = number>(response: Response) {\n  const contentType = response.headers.get('Content-Type');\n  const isJSON = contentType && (matchesMimeType.json(contentType) || matchesMimeType.wildcard(contentType));\n\n  const responseBody = await response.clone().text();\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let data: any = responseBody;\n  if (isJSON) {\n    try {\n      data = JSON.parse(responseBody);\n    } catch (e) {\n      // If our JSON parsing failed then we can just return plaintext instead.\n    }\n  }\n\n  return {\n    data,\n    status: response.status as HTTPStatus,\n    headers: response.headers,\n    res: response,\n  };\n}\n","/* eslint-disable no-underscore-dangle */\nimport type { AuthForHAR } from '@readme/oas-to-har/lib/types';\nimport type { Operation } from 'oas/operation';\nimport type { KeyedSecuritySchemeObject } from 'oas/types';\n\nexport default function prepareAuth(authKey: (number | string)[], operation: Operation) {\n  if (authKey.length === 0) {\n    return {};\n  }\n\n  const preparedAuth: AuthForHAR = {};\n\n  const security = operation.getSecurity();\n  if (security.length === 0) {\n    // If there's no auth configured on this operation, don't prepare anything (even if it was\n    // supplied by the user).\n    return {};\n  }\n\n  // Does this operation require multiple forms of auth?\n  if (security.every(s => Object.keys(s).length > 1)) {\n    throw new Error(\n      \"Sorry, this operation currently requires multiple forms of authentication which this library doesn't yet support.\",\n    );\n  }\n\n  // Since we can only handle single auth security configurations, let's pull those out. This code\n  // is a bit opaque but `security` here may look like `[{ basic: [] }, { oauth2: [], basic: []}]`\n  // and are filtering it down to only single-auth requirements of `[{ basic: [] }]`.\n  const usableSecurity = security\n    .map(s => {\n      return Object.keys(s).length === 1 ? s : false;\n    })\n    .filter(Boolean);\n\n  const usableSecuritySchemes = usableSecurity.map(s => Object.keys(s)).reduce((prev, next) => prev.concat(next), []);\n  const preparedSecurity = operation.prepareSecurity();\n\n  // If we have two auth tokens present let's look for Basic Auth in their configuration.\n  if (authKey.length >= 2) {\n    // If this operation doesn't support HTTP Basic auth but we have two tokens, that's a paddlin.\n    if (!('Basic' in preparedSecurity)) {\n      throw new Error('Multiple auth tokens were supplied for this endpoint but only a single token is needed.');\n    }\n\n    // If we have two auth keys for Basic Auth but Basic isn't a usable security scheme (maybe it's\n    // part of an AND or auth configuration -- which we don't support) then we need to error out.\n    const schemes = preparedSecurity.Basic.filter(s => usableSecuritySchemes.includes(s._key));\n    if (!schemes.length) {\n      throw new Error(\n        'Credentials for Basic Authentication were supplied but this operation requires another form of auth in that case, which this library does not yet support. This operation does, however, allow supplying a single auth token.',\n      );\n    }\n\n    const scheme = schemes.shift() as KeyedSecuritySchemeObject;\n    preparedAuth[scheme._key] = {\n      user: String(authKey[0]),\n      pass: authKey.length === 2 ? String(authKey[1]) : '',\n    };\n\n    return preparedAuth;\n  }\n\n  // If we know we don't need to use HTTP Basic auth because we have a username+password then we\n  // can pick the first usable security scheme available and try to use that. This might not always\n  // be the auth scheme that the user wants, but we don't have any other way for the user to tell\n  // us what they want with the current `sdk.auth()` API.\n  const usableScheme = usableSecuritySchemes[0];\n  const schemes = Object.entries(preparedSecurity)\n    .map(([, ps]) => ps.filter(s => usableScheme === s._key))\n    .reduce((prev, next) => prev.concat(next), []);\n\n  const scheme = schemes.shift() as KeyedSecuritySchemeObject;\n  switch (scheme.type) {\n    case 'http':\n      if (scheme.scheme === 'basic') {\n        preparedAuth[scheme._key] = {\n          user: String(authKey[0]),\n          pass: authKey.length === 2 ? String(authKey[1]) : '',\n        };\n      } else if (scheme.scheme === 'bearer') {\n        preparedAuth[scheme._key] = authKey[0];\n      }\n      break;\n\n    case 'oauth2':\n      preparedAuth[scheme._key] = authKey[0];\n      break;\n\n    case 'apiKey':\n      if (scheme.in === 'query' || scheme.in === 'header' || scheme.in === 'cookie') {\n        preparedAuth[scheme._key] = authKey[0];\n      }\n      break;\n\n    default:\n      throw new Error(\n        `Sorry, this API currently uses a security scheme, ${scheme.type}, which this library doesn't yet support.`,\n      );\n  }\n\n  return preparedAuth;\n}\n","import type { ReadStream } from 'node:fs';\nimport type { Operation } from 'oas/operation';\nimport type { ParameterObject, SchemaObject } from 'oas/types';\n\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport stream from 'node:stream';\n\nimport caseless from 'caseless';\nimport DatauriParser from 'datauri/parser.js';\nimport datauri from 'datauri/sync.js';\n// `get-stream` is included in our bundle, see `tsup.config.ts`\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { getStreamAsBuffer } from 'get-stream';\nimport lodashMerge from 'lodash.merge';\nimport removeUndefinedObjects from 'remove-undefined-objects';\n\nimport getJSONSchemaDefaults from './getJSONSchemaDefaults.js';\n\n// These headers are normally only defined by the OpenAPI definition but we allow the user to\n// manually supply them in their `metadata` parameter if they wish.\nconst specialHeaders = ['accept', 'authorization'];\n\n/**\n * Extract all available parameters from an operations Parameter Object into a digestable array\n * that we can use to apply to the request.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameterObject}\n */\nfunction digestParameters(parameters: ParameterObject[]): Record<string, ParameterObject> {\n  return parameters.reduce((prev, param) => {\n    if ('$ref' in param || 'allOf' in param || 'anyOf' in param || 'oneOf' in param) {\n      throw new Error(\"The OpenAPI document for this operation wasn't dereferenced before processing.\");\n    } else if (param.name in prev) {\n      throw new Error(\n        `The operation you are using has the same parameter, ${param.name}, spread across multiple entry points. We unfortunately can't handle this right now.`,\n      );\n    }\n\n    return Object.assign(prev, { [param.name]: param });\n  }, {});\n}\n\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isEmpty(obj: any) {\n  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;\n}\n\nfunction isObject(thing: unknown) {\n  if (thing instanceof stream.Readable) {\n    return false;\n  }\n\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n\nfunction isPrimitive(obj: unknown) {\n  return obj === null || typeof obj === 'number' || typeof obj === 'string';\n}\n\nfunction merge(src: unknown, target: unknown) {\n  if (Array.isArray(target)) {\n    // @todo we need to add support for merging array defaults with array body/metadata arguments\n    return target;\n  } else if (!isObject(target)) {\n    return target;\n  }\n\n  return lodashMerge(src, target);\n}\n\n/**\n * Ingest a file path or readable stream into a common object that we can later use to process it\n * into a parameters object for making an API request.\n *\n */\nfunction processFile(\n  paramName: string | undefined,\n  file: string | ReadStream,\n): Promise<{ base64?: string; buffer?: Buffer; filename: string; paramName?: string } | undefined> {\n  if (typeof file === 'string') {\n    // In order to support relative pathed files, we need to attempt to resolve them.\n    const resolvedFile = path.resolve(file);\n\n    return new Promise((resolve, reject) => {\n      fs.stat(resolvedFile, async err => {\n        if (err) {\n          if (err.code === 'ENOENT') {\n            // It's less than ideal for us to handle files that don't exist like this but because\n            // `file` is a string it might actually be the full text contents of the file and not\n            // actually a path.\n            //\n            // We also can't really regex to see if `file` *looks*` like a path because one should be\n            // able to pass in a relative `owlbert.png` (instead of `./owlbert.png`) and though that\n            // doesn't *look* like a path, it is one that should still work.\n            return resolve(undefined);\n          }\n\n          return reject(err);\n        }\n\n        const fileMetadata = await datauri(resolvedFile);\n        const payloadFilename = encodeURIComponent(path.basename(resolvedFile));\n\n        return resolve({\n          paramName,\n          base64: fileMetadata?.content?.replace(';base64', `;name=${payloadFilename};base64`),\n          filename: payloadFilename,\n          buffer: fileMetadata.buffer,\n        });\n      });\n    });\n  } else if (file instanceof stream.Readable) {\n    return getStreamAsBuffer(file).then(buffer => {\n      const filePath = file.path as string;\n      const parser = new DatauriParser();\n      const base64 = parser.format(filePath, buffer).content;\n      const payloadFilename = encodeURIComponent(path.basename(filePath));\n\n      return {\n        paramName,\n        base64: base64?.replace(';base64', `;name=${payloadFilename};base64`),\n        filename: payloadFilename,\n        buffer,\n      };\n    });\n  }\n\n  return Promise.reject(\n    new TypeError(\n      paramName\n        ? `The data supplied for the \\`${paramName}\\` request body parameter is not a file handler that we support.`\n        : 'The data supplied for the request body payload is not a file handler that we support.',\n    ),\n  );\n}\n\n/**\n * With potentially supplied body and/or metadata we need to run through them against a given API\n * operation to see what's what and prepare any available parameters to be used in an API request\n * with `@readme/oas-to-har`.\n *\n */\nexport default async function prepareParams(operation: Operation, body?: unknown, metadata?: Record<string, unknown>) {\n  let metadataIntersected = false;\n  const digestedParameters = digestParameters(operation.getParameters());\n  const jsonSchema = operation.getParametersAsJSONSchema();\n\n  /**\n   * It might be common for somebody to run `sdk.findPetsByStatus({ status: 'available' }, {})`, in\n   * which case we want to filter out the second (metadata) parameter and treat the first parameter\n   * as the metadata instead. If we don't do this, their supplied `status` metadata will be treated\n   * as a body parameter, and because there's no `status` body parameter, and no supplied metadata\n   * (because it's an empty object), the request won't send a payload.\n   *\n   * @see {@link https://github.com/readmeio/api/issues/449}\n   */\n  // eslint-disable-next-line no-param-reassign\n  metadata = removeUndefinedObjects(metadata);\n\n  if (!jsonSchema && (body !== undefined || metadata !== undefined)) {\n    let throwNoParamsError = true;\n\n    // If this operation doesn't have any parameters for us to transform to JSON Schema but they've\n    // sent us either an `Accept` or `Authorization` header (or both) we should let them do that.\n    // We should, however, only do this check for the `body` parameter as if they've sent this\n    // request both `body` and `metadata` we can reject it outright as the operation won't have any\n    // body data.\n    if (body !== undefined) {\n      if (typeof body === 'object' && body !== null && !Array.isArray(body)) {\n        if (Object.keys(body).length <= 2) {\n          const bodyParams = caseless(body);\n\n          if (specialHeaders.some(header => bodyParams.has(header))) {\n            throwNoParamsError = false;\n          }\n        }\n      }\n    }\n\n    if (throwNoParamsError) {\n      throw new Error(\n        \"You supplied metadata and/or body data for this operation but it doesn't have any documented parameters or request payloads. If you think this is an error please contact support for the API you're using.\",\n      );\n    }\n  }\n\n  const jsonSchemaDefaults = jsonSchema ? getJSONSchemaDefaults(jsonSchema) : {};\n\n  const params: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    body?: any;\n    cookie?: Record<string, string | number | boolean>;\n    files?: Record<string, Buffer>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    formData?: any;\n    header?: Record<string, string | number | boolean>;\n    path?: Record<string, string | number | boolean>;\n    query?: Record<string, string | number | boolean>;\n    server?: {\n      selected: number;\n      variables: Record<string, string | number>;\n    };\n  } = jsonSchemaDefaults;\n\n  // If a body argument was supplied we need to do a bit of work to see if it's actually a body\n  // argument or metadata because the library lets you supply either a body, metadata, or body with\n  // metadata.\n  if (typeof body !== 'undefined') {\n    if (Array.isArray(body) || isPrimitive(body)) {\n      // If the body param is an array or a primitive then we know it's absolutely a body because\n      // metadata can only ever be undefined or an object.\n      params.body = merge(params.body, body);\n    } else if (typeof metadata === 'undefined') {\n      // No metadata was explicitly provided so we need to analyze the body to determine if it's a\n      // body or should be actually be treated as metadata.\n      const headerParams = caseless({});\n      Object.entries(digestedParameters).forEach(([paramName, param]) => {\n        // Headers are sent case-insensitive so we need to make sure that we're properly\n        // matching them when detecting what our incoming payload looks like.\n        if (param.in === 'header') {\n          headerParams.set(paramName, '');\n        }\n      });\n\n      // `Accept` and `Authorization` headers can't be defined as normal parameters but we should\n      // always allow the user to supply them if they wish.\n      specialHeaders.forEach(header => {\n        if (!headerParams.has(header)) {\n          headerParams.set(header, '');\n        }\n      });\n\n      const intersection = Object.keys(body as NonNullable<unknown>).filter(value => {\n        if (Object.keys(digestedParameters).includes(value)) {\n          return true;\n        } else if (headerParams.has(value)) {\n          return true;\n        }\n\n        return false;\n      }).length;\n\n      // If more than 25% of the body intersects with the parameters that we've got on hand, then\n      // we should treat it as a metadata object and organize into parameters.\n      if (intersection && intersection / Object.keys(body as NonNullable<unknown>).length > 0.25) {\n        /* eslint-disable no-param-reassign */\n        metadataIntersected = true;\n        metadata = merge(params.body, body) as Record<string, unknown>;\n        body = undefined;\n        /* eslint-enable no-param-reassign */\n      } else {\n        // For all other cases, we should just treat the supplied body as a body.\n        params.body = merge(params.body, body);\n      }\n    } else {\n      // Body and metadata were both supplied.\n      params.body = merge(params.body, body);\n    }\n  }\n\n  if (!operation.hasRequestBody()) {\n    // If this operation doesn't have any documented request body then we shouldn't be sending\n    // anything.\n    delete params.body;\n  } else {\n    if (!('body' in params)) params.body = {};\n\n    // We need to retrieve the request body for this operation to search for any `binary` format\n    // data that the user wants to send so we know what we need to prepare for the final API\n    // request.\n    const payloadJsonSchema = jsonSchema.find(js => js.type === 'body');\n    if (payloadJsonSchema) {\n      if (!params.files) params.files = {};\n\n      const conversions = [];\n\n      // @todo add support for `type: array`, `oneOf` and `anyOf`\n      if (payloadJsonSchema.schema?.properties) {\n        Object.entries(payloadJsonSchema.schema?.properties)\n          .filter(([, schema]: [string, SchemaObject]) => schema?.format === 'binary')\n          .filter(([prop]) => Object.keys(params.body).includes(prop))\n          .forEach(([prop]) => {\n            conversions.push(processFile(prop, params.body[prop]));\n          });\n      } else if (payloadJsonSchema.schema?.type === 'string') {\n        if (payloadJsonSchema.schema?.format === 'binary') {\n          conversions.push(processFile(undefined, params.body));\n        }\n      }\n\n      await Promise.all(conversions)\n        .then(fileMetadata => fileMetadata.filter(Boolean))\n        .then(fm => {\n          fm.forEach(fileMetadata => {\n            if (!fileMetadata) {\n              // If we don't have any metadata here it's because the file we have is likely\n              // the full string content of the file so since we don't have any filenames to\n              // work with we shouldn't do any additional handling to the `body` or `files`\n              // parameters.\n              return;\n            }\n\n            if (fileMetadata.paramName) {\n              params.body[fileMetadata.paramName] = fileMetadata.base64;\n            } else {\n              params.body = fileMetadata.base64;\n            }\n\n            if (fileMetadata.buffer && params?.files) {\n              params.files[fileMetadata.filename] = fileMetadata.buffer;\n            }\n          });\n        });\n    }\n  }\n\n  // Form data should be placed within `formData` instead of `body` for it to properly get picked\n  // up by `fetch-har`.\n  if (operation.isFormUrlEncoded()) {\n    params.formData = merge(params.formData, params.body);\n    delete params.body;\n  }\n\n  // Only spend time trying to organize metadata into parameters if we were able to digest\n  // parameters out of the operation schema. If we couldn't digest anything, but metadata was\n  // supplied then we wouldn't know how to send it in the request!\n  if (typeof metadata !== 'undefined') {\n    if (!('cookie' in params)) params.cookie = {};\n    if (!('header' in params)) params.header = {};\n    if (!('path' in params)) params.path = {};\n    if (!('query' in params)) params.query = {};\n\n    Object.entries(digestedParameters).forEach(([paramName, param]) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value: any;\n      let metadataHeaderParam;\n      if (typeof metadata === 'object' && !isEmpty(metadata)) {\n        if (paramName in metadata) {\n          value = metadata[paramName];\n          metadataHeaderParam = paramName;\n        } else if (param.in === 'header') {\n          // Headers are sent case-insensitive so we need to make sure that we're properly\n          // matching them when detecting what our incoming payload looks like.\n          metadataHeaderParam = Object.keys(metadata).find(k => k.toLowerCase() === paramName.toLowerCase()) || '';\n          value = metadata[metadataHeaderParam];\n        }\n      }\n\n      if (value === undefined) {\n        return;\n      }\n\n      /* eslint-disable no-param-reassign */\n      switch (param.in) {\n        case 'path':\n          (params.path as NonNullable<typeof params.path>)[paramName] = value;\n          if (metadata?.[paramName]) delete metadata[paramName];\n          break;\n        case 'query':\n          (params.query as NonNullable<typeof params.query>)[paramName] = value;\n          if (metadata?.[paramName]) delete metadata[paramName];\n          break;\n        case 'header':\n          (params.header as NonNullable<typeof params.header>)[paramName.toLowerCase()] = value;\n          if (metadataHeaderParam && metadata?.[metadataHeaderParam]) delete metadata[metadataHeaderParam];\n          break;\n        case 'cookie':\n          (params.cookie as NonNullable<typeof params.cookie>)[paramName] = value;\n          if (metadata?.[paramName]) delete metadata[paramName];\n          break;\n        default: // no-op\n      }\n      /* eslint-enable no-param-reassign */\n\n      // Because a user might have sent just a metadata object, we want to make sure that we filter\n      // out anything that they sent that is a parameter from also being sent as part of a form\n      // data payload for `x-www-form-urlencoded` requests.\n      if (metadataIntersected && operation.isFormUrlEncoded()) {\n        if (paramName in params.formData) {\n          delete params.formData[paramName];\n        }\n      }\n    });\n\n    // If there's any leftover metadata that hasn't been moved into form data for this request we\n    // need to move it or else it'll get tossed.\n    if (!isEmpty(metadata)) {\n      if (typeof metadata === 'object') {\n        // If the user supplied an `accept` or `authorization` header themselves we should allow it\n        // through. Normally these headers are automatically handled by `@readme/oas-to-har` but in\n        // the event that maybe the user wants to return XML for an API that normally returns JSON\n        // or specify a custom auth header (maybe we can't handle their auth case right) this is the\n        // only way with this library that they can do that.\n        specialHeaders.forEach(headerName => {\n          const headerParam = Object.keys(metadata || {}).find(m => m.toLowerCase() === headerName);\n          if (headerParam) {\n            // this if-statement below is a typeguard\n            if (typeof metadata === 'object') {\n              // this if-statement below is a typeguard\n              if (typeof params.header === 'object') {\n                params.header[headerName] = metadata[headerParam] as string;\n              }\n              // eslint-disable-next-line no-param-reassign\n              delete metadata[headerParam];\n            }\n          }\n        });\n      }\n\n      if (operation.isFormUrlEncoded()) {\n        params.formData = merge(params.formData, metadata);\n      } else {\n        // Any other remaining unused metadata will be unused because we don't know where to place\n        // it in the request.\n      }\n    }\n  }\n\n  (['body', 'cookie', 'files', 'formData', 'header', 'path', 'query'] as const).forEach((type: keyof typeof params) => {\n    if (type in params && isEmpty(params[type])) {\n      delete params[type];\n    }\n  });\n\n  return params;\n}\n","export const getStreamContents = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {\n\tif (!isAsyncIterable(stream)) {\n\t\tthrow new Error('The first argument must be a Readable, a ReadableStream, or an async iterable.');\n\t}\n\n\tconst state = init();\n\tstate.length = 0;\n\n\ttry {\n\t\tfor await (const chunk of stream) {\n\t\t\tconst chunkType = getChunkType(chunk);\n\t\t\tconst convertedChunk = convertChunk[chunkType](chunk, state);\n\t\t\tappendChunk({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer});\n\t\t}\n\n\t\tappendFinalChunk({state, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer});\n\t\treturn finalize(state);\n\t} catch (error) {\n\t\terror.bufferedData = finalize(state);\n\t\tthrow error;\n\t}\n};\n\nconst appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {\n\tconst convertedChunk = getFinalChunk(state);\n\tif (convertedChunk !== undefined) {\n\t\tappendChunk({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer});\n\t}\n};\n\nconst appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {\n\tconst chunkSize = getSize(convertedChunk);\n\tconst newLength = state.length + chunkSize;\n\n\tif (newLength <= maxBuffer) {\n\t\taddNewChunk(convertedChunk, state, addChunk, newLength);\n\t\treturn;\n\t}\n\n\tconst truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);\n\n\tif (truncatedChunk !== undefined) {\n\t\taddNewChunk(truncatedChunk, state, addChunk, maxBuffer);\n\t}\n\n\tthrow new MaxBufferError();\n};\n\nconst addNewChunk = (convertedChunk, state, addChunk, newLength) => {\n\tstate.contents = addChunk(convertedChunk, state, newLength);\n\tstate.length = newLength;\n};\n\nconst isAsyncIterable = stream => typeof stream === 'object' && stream !== null && typeof stream[Symbol.asyncIterator] === 'function';\n\nconst getChunkType = chunk => {\n\tconst typeOfChunk = typeof chunk;\n\n\tif (typeOfChunk === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (typeOfChunk !== 'object' || chunk === null) {\n\t\treturn 'others';\n\t}\n\n\t// eslint-disable-next-line n/prefer-global/buffer\n\tif (globalThis.Buffer?.isBuffer(chunk)) {\n\t\treturn 'buffer';\n\t}\n\n\tconst prototypeName = objectToString.call(chunk);\n\n\tif (prototypeName === '[object ArrayBuffer]') {\n\t\treturn 'arrayBuffer';\n\t}\n\n\tif (prototypeName === '[object DataView]') {\n\t\treturn 'dataView';\n\t}\n\n\tif (\n\t\tNumber.isInteger(chunk.byteLength)\n\t\t&& Number.isInteger(chunk.byteOffset)\n\t\t&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'\n\t) {\n\t\treturn 'typedArray';\n\t}\n\n\treturn 'others';\n};\n\nconst {toString: objectToString} = Object.prototype;\n\nexport class MaxBufferError extends Error {\n\tname = 'MaxBufferError';\n\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t}\n}\n","export const identity = value => value;\n\nexport const noop = () => undefined;\n\nexport const getContentsProp = ({contents}) => contents;\n\nexport const throwObjectStream = chunk => {\n\tthrow new Error(`Streams in object mode are not supported: ${String(chunk)}`);\n};\n\nexport const getLengthProp = convertedChunk => convertedChunk.length;\n","import {getStreamContents} from './contents.js';\nimport {noop, throwObjectStream, getLengthProp} from './utils.js';\n\nexport async function getStreamAsArrayBuffer(stream, options) {\n\treturn getStreamContents(stream, arrayBufferMethods, options);\n}\n\nconst initArrayBuffer = () => ({contents: new ArrayBuffer(0)});\n\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\n\nconst useUint8Array = chunk => new Uint8Array(chunk);\n\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {\n\tconst newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n\tnew Uint8Array(newContents).set(convertedChunk, previousLength);\n\treturn newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n\tif (length <= contents.byteLength) {\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n\tif (length <= contents.maxByteLength) {\n\t\tcontents.resize(length);\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\n\nconst SCALE_FACTOR = 2;\n\nconst finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\n\nconst arrayBufferMethods = {\n\tinit: initArrayBuffer,\n\tconvertChunk: {\n\t\tstring: useTextEncoder,\n\t\tbuffer: useUint8Array,\n\t\tarrayBuffer: useUint8Array,\n\t\tdataView: useUint8ArrayWithOffset,\n\t\ttypedArray: useUint8ArrayWithOffset,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProp,\n\ttruncateChunk: truncateArrayBufferChunk,\n\taddChunk: addArrayBufferChunk,\n\tgetFinalChunk: noop,\n\tfinalize: finalizeArrayBuffer,\n};\n","import {getStreamAsArrayBuffer} from './array-buffer.js';\n\nexport async function getStreamAsBuffer(stream, options) {\n\tif (!('Buffer' in globalThis)) {\n\t\tthrow new Error('getStreamAsBuffer() is only supported in Node.js');\n\t}\n\n\ttry {\n\t\treturn arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream, options));\n\t} catch (error) {\n\t\tif (error.bufferedData !== undefined) {\n\t\t\terror.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\n// eslint-disable-next-line n/prefer-global/buffer\nconst arrayBufferToNodeBuffer = arrayBuffer => globalThis.Buffer.from(arrayBuffer);\n","import type Oas from 'oas';\n\nfunction stripTrailingSlash(url: string) {\n  if (url[url.length - 1] === '/') {\n    return url.slice(0, -1);\n  }\n\n  return url;\n}\n\n/**\n * With an SDK server config and an instance of OAS we should extract and prepare the server and\n * any server variables to be supplied to `@readme/oas-to-har`.\n *\n */\nexport default function prepareServer(spec: Oas, url: string, variables: Record<string, string | number> = {}) {\n  let serverIdx: number | undefined;\n  const sanitizedUrl = stripTrailingSlash(url);\n  (spec.api.servers || []).forEach((server, i) => {\n    if (server.url === sanitizedUrl) {\n      serverIdx = i;\n    }\n  });\n\n  // If we were able to find the passed in server in the OAS servers, we should use that! If we\n  // couldn't and server variables were passed in we should try our best to handle that, otherwise\n  // we should ignore the passed in server and use whever the default from the OAS is.\n  if (serverIdx !== undefined) {\n    return {\n      selected: serverIdx,\n      variables,\n    };\n  } else if (Object.keys(variables).length) {\n    // @todo we should run `oas.replaceUrl(url)` and pass that unto `@readme/oas-to-har`\n  } else {\n    const server = spec.splitVariables(url);\n    if (server) {\n      return {\n        selected: server.selected,\n        variables: server.variables,\n      };\n    }\n\n    // @todo we should pass `url` directly into `@readme/oas-to-har` as the base URL\n  }\n\n  return false;\n}\n"],"mappings":"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","names":["schemes","scheme","stream","stream","stream"]}