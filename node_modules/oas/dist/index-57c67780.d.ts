import { SchemaObject, OASDocument, OperationObject, HttpMethods, SecurityRequirementObject, KeyedSecuritySchemeObject, TagObject, ParameterObject, MediaTypeObject, ResponseObject, PathItemObject, OAS31Document } from './types.cjs';

interface SchemaWrapper {
    $schema?: string;
    deprecatedProps?: SchemaWrapper;
    description?: string;
    label?: string;
    schema: SchemaObject;
    type: string;
}
/**
 * The order of this object determines how they will be sorted in the compiled JSON Schema
 * representation.
 *
 * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#parameterObject}
 * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameterObject}
 */
declare const types: Record<keyof OASDocument, string>;
interface getParametersAsJSONSchemaOptions {
    /**
     * Contains an object of user defined schema defaults.
     */
    globalDefaults?: Record<string, unknown>;
    /**
     * If you wish to hide properties that are marked as being `readOnly`.
     */
    hideReadOnlyProperties?: boolean;
    /**
     * If you wish to hide properties that are marked as being `writeOnly`.
     */
    hideWriteOnlyProperties?: boolean;
    /**
     * If you wish to include discriminator mapping `$ref` components alongside your
     * `discriminator` in schemas. Defaults to `true`.
     */
    includeDiscriminatorMappingRefs?: boolean;
    /**
     * If you want the output to be two objects: body (contains `body` and `formData` JSON
     * Schema) and metadata (contains `path`, `query`, `cookie`, and `header`).
     */
    mergeIntoBodyAndMetadata?: boolean;
    /**
     * If you wish to **not** split out deprecated properties into a separate `deprecatedProps`
     * object.
     */
    retainDeprecatedProperties?: boolean;
    /**
     * With a transformer you can transform any data within a given schema, like say if you want
     * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable
     * name, just make sure to return your transformed schema.
     */
    transformer?: (schema: SchemaObject) => SchemaObject;
}
declare function getParametersAsJSONSchema(operation: Operation, api: OASDocument, opts?: getParametersAsJSONSchemaOptions): SchemaWrapper[];

type CallbackExamples = {
    example: unknown;
    expression: string;
    identifier: string;
    method: string;
}[];

type RequestBodyExamples = {
    examples: any;
    mediaType: string;
}[];

interface MediaTypeExample {
    description?: string;
    summary?: string;
    title?: string;
    value: unknown;
}

type ResponseExamples = {
    mediaTypes: Record<string, MediaTypeExample[]>;
    onlyHeaders?: boolean;
    status: string;
}[];

type SecurityType = 'Basic' | 'Bearer' | 'Query' | 'Header' | 'Cookie' | 'OAuth2' | 'http' | 'apiKey';
declare class Operation {
    /**
     * Schema of the operation from the API Definition.
     */
    schema: OperationObject;
    /**
     * OpenAPI API Definition that this operation originated from.
     */
    api: OASDocument;
    /**
     * Path that this operation is targeted towards.
     */
    path: string;
    /**
     * HTTP Method that this operation is targeted towards.
     */
    method: HttpMethods;
    /**
     * The primary Content Type that this operation accepts.
     */
    contentType: string;
    /**
     * Request body examples for this operation.
     */
    requestBodyExamples: RequestBodyExamples;
    /**
     * Response examples for this operation.
     */
    responseExamples: ResponseExamples;
    /**
     * Callback examples for this operation (if it has callbacks).
     */
    callbackExamples: CallbackExamples;
    /**
     * Flattened out arrays of both request and response headers that are utilized on this operation.
     */
    headers: {
        request: string[];
        response: string[];
    };
    constructor(api: OASDocument, path: string, method: HttpMethods, operation: OperationObject);
    getSummary(): string;
    getDescription(): string;
    getContentType(): string;
    isFormUrlEncoded(): boolean;
    isMultipart(): boolean;
    isJson(): boolean;
    isXml(): boolean;
    /**
     * Returns an array of all security requirements associated wtih this operation. If none are
     * defined at the operation level, the securities for the entire API definition are returned
     * (with an empty array as a final fallback).
     *
     */
    getSecurity(): SecurityRequirementObject[];
    /**
     * Retrieve a collection of grouped security schemes. The inner array determines AND-grouped
     * security schemes, the outer array determines OR-groups.
     *
     * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#securityRequirementObject}
     * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent
     *    security schemes, rather than returning `false`.
     */
    getSecurityWithTypes(filterInvalid?: boolean): (false | (false | {
        security: KeyedSecuritySchemeObject;
        type: SecurityType;
    })[])[];
    /**
     * Retrieve an object where the keys are unique scheme types, and the values are arrays
     * containing each security scheme of that type.
     *
     */
    prepareSecurity(): Record<SecurityType, KeyedSecuritySchemeObject[]>;
    getHeaders(): Operation['headers'];
    /**
     * Determine if the operation has an operation present in its schema. Note that if one is present
     * in the schema but is an empty string then this will return false.
     *
     */
    hasOperationId(): boolean;
    /**
     * Get an `operationId` for this operation. If one is not present (it's not required by the spec!)
     * a hash of the path and method will be returned instead.
     *
     */
    getOperationId(opts?: {
        /**
         * Generate a JS method-friendly operation ID when one isn't present.
         */
        camelCase: boolean;
    }): string;
    /**
     * Return an array of all tags, and their metadata, that exist on this operation.
     *
     */
    getTags(): TagObject[];
    /**
     * Return is the operation is flagged as `deprecated` or not.
     *
     */
    isDeprecated(): boolean;
    /**
     * Determine if the operation has any (non-request body) parameters.
     *
     */
    hasParameters(): boolean;
    /**
     * Return the parameters (non-request body) on the operation.
     *
     */
    getParameters(): ParameterObject[];
    /**
     * Determine if this operation has any required parameters.
     *
     */
    hasRequiredParameters(): boolean;
    /**
     * Convert the operation into an array of JSON Schema schemas for each available type of
     * parameter available on the operation.
     *
     */
    getParametersAsJSONSchema(opts?: getParametersAsJSONSchemaOptions): SchemaWrapper[];
    /**
     * Get a single response for this status code, formatted as JSON schema.
     *
     * @param statusCode Status code to pull a JSON Schema response for.
     */
    getResponseAsJSONSchema(statusCode: string | number, opts?: {
        /**
         * If you wish to include discriminator mapping `$ref` components alongside your
         * `discriminator` in schemas. Defaults to `true`.
         */
        includeDiscriminatorMappingRefs?: boolean;
        /**
         * With a transformer you can transform any data within a given schema, like say if you want
         * to rewrite a potentially unsafe `title` that might be eventually used as a JS variable
         * name, just make sure to return your transformed schema.
         */
        transformer?: (schema: SchemaObject) => SchemaObject;
    }): {
        description?: string;
        label: string;
        schema: SchemaObject;
        type: string | string[];
    }[];
    /**
     * Get an array of all valid response status codes for this operation.
     *
     */
    getResponseStatusCodes(): string[];
    /**
     * Determine if the operation has any request bodies.
     *
     */
    hasRequestBody(): boolean;
    /**
     * Retrieve the list of all available media types that the operations request body can accept.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
     */
    getRequestBodyMediaTypes(): string[];
    /**
     * Determine if this operation has a required request body.
     *
     */
    hasRequiredRequestBody(): boolean;
    /**
     * Retrieve a specific request body content schema off this operation.
     *
     * If no media type is supplied this will return either the first available JSON-like request
     * body, or the first available if there are no JSON-like media types present. When this return
     * comes back it's in the form of an array with the first key being the selected media type,
     * followed by the media type object in question.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
     * @param mediaType Specific request body media type to retrieve if present.
     */
    getRequestBody(mediaType?: string): false | MediaTypeObject | [string, MediaTypeObject, ...string[]];
    /**
     * Retrieve an array of request body examples that this operation has.
     *
     */
    getRequestBodyExamples(): RequestBodyExamples;
    /**
     * Return a specific response out of the operation by a given HTTP status code.
     *
     * @param statusCode Status code to pull a response object for.
     */
    getResponseByStatusCode(statusCode: string | number): boolean | ResponseObject;
    /**
     * Retrieve an array of response examples that this operation has.
     *
     */
    getResponseExamples(): ResponseExamples;
    /**
     * Determine if the operation has callbacks.
     *
     */
    hasCallbacks(): boolean;
    /**
     * Retrieve a specific callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callbackObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     * @param identifier Callback identifier to look for.
     * @param expression Callback expression to look for.
     * @param method HTTP Method on the callback to look for.
     */
    getCallback(identifier: string, expression: string, method: HttpMethods): false | Callback;
    /**
     * Retrieve an array of operations created from each callback.
     *
     */
    getCallbacks(): false | (false | Callback)[];
    /**
     * Retrieve an array of callback examples that this operation has.
     *
     */
    getCallbackExamples(): CallbackExamples;
    /**
     * Determine if a given a custom specification extension exists within the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     */
    hasExtension(extension: string): boolean;
    /**
     * Retrieve a custom specification extension off of the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     */
    getExtension(extension: string): unknown;
}
declare class Callback extends Operation {
    /**
     * The identifier that this callback is set to.
     */
    identifier: string;
    /**
     * The parent path item object that this Callback exists within.
     */
    parentSchema: PathItemObject;
    constructor(oas: OASDocument, path: string, method: HttpMethods, operation: OperationObject, identifier: string, parentPathItem: PathItemObject);
    /**
     * Return the primary identifier for this callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     */
    getIdentifier(): string;
    getSummary(): string;
    getDescription(): string;
    getParameters(): ParameterObject[];
}
declare class Webhook extends Operation {
    /**
     * OpenAPI API Definition that this webhook originated from.
     */
    api: OAS31Document;
    getSummary(): string;
    getDescription(): string;
}

export { Callback as C, Operation as O, SchemaWrapper as S, Webhook as W, getParametersAsJSONSchema as a, getParametersAsJSONSchemaOptions as g, types as t };
