{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { FetchHAROptions, RequestInitWithDuplex } from './types.js';\nimport type { DataURL as npmDataURL } from '@readme/data-urls';\nimport type { Har } from 'har-format';\n\nimport { parse as parseDataUrl } from '@readme/data-urls';\n\ntype DataURL = npmDataURL & {\n  // `parse-data-url` doesn't explicitly support `name` in data URLs but if it's there it'll be\n  // returned back to us.\n  name?: string;\n};\n\nfunction isBrowser() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\nfunction isBuffer(value: any) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n}\n\nfunction isFile(value: any) {\n  if (value instanceof File) {\n    /**\n     * The `Blob` polyfill on Node comes back as being an instanceof `File`. Because passing a Blob\n     * into a File will end up with a corrupted file we want to prevent this.\n     *\n     * This object identity crisis does not happen in the browser.\n     */\n    return value.constructor.name === 'File';\n  }\n\n  return false;\n}\n\nfunction getFileFromSuppliedFiles(filename: string, files: FetchHAROptions['files']) {\n  if (files && filename in files) {\n    return files[filename];\n  } else if (files && decodeURIComponent(filename) in files) {\n    return files[decodeURIComponent(filename)];\n  }\n\n  return false;\n}\n\nexport default async function fetchHAR(har: Har, opts: FetchHAROptions = {}): Promise<Response> {\n  if (!har) throw new Error('Missing HAR definition');\n  if (!har.log || !har.log.entries || !har.log.entries.length) throw new Error('Missing log.entries array');\n\n  if (!globalThis.Blob) {\n    try {\n      const NodeBlob = (await import('node:buffer')).Blob;\n      // @ts-expect-error the types don't match exactly, which is expected!\n      globalThis.Blob = NodeBlob;\n    } catch (e) {\n      throw new Error(\n        'The Blob API is required for this library. https://developer.mozilla.org/en-US/docs/Web/API/Blob',\n      );\n    }\n  }\n\n  if (!globalThis.File) {\n    try {\n      const NodeFile = (await import('node:buffer')).File;\n      // @ts-expect-error the types don't match exactly, which is expected!\n      globalThis.File = NodeFile;\n    } catch (e) {\n      throw new Error(\n        'The File API is required for this library. https://developer.mozilla.org/en-US/docs/Web/API/File',\n      );\n    }\n  }\n\n  const { request } = har.log.entries[0];\n  const { url } = request;\n  let querystring = '';\n  let shouldSetDuplex = false;\n\n  const options: RequestInitWithDuplex = {\n    // If we have custom options for the `Request` API we need to add them in here now before we\n    // fill it in with everything we need from the HAR.\n    ...(opts.init ? opts.init : {}),\n    method: request.method,\n  };\n\n  if (!options.headers) {\n    options.headers = new Headers();\n  } else if (typeof options.headers === 'object' && !(options.headers instanceof Headers) && options.headers !== null) {\n    options.headers = new Headers(options.headers);\n  }\n\n  const headers = options.headers as Headers;\n  if ('headers' in request && request.headers.length) {\n    // eslint-disable-next-line consistent-return\n    request.headers.forEach(header => {\n      try {\n        return headers.append(header.name, header.value);\n      } catch (err) {\n        /**\n         * `Headers.append()` will throw errors if the header name is not a legal HTTP header name,\n         * like `X-API-KEY (Header)`. If that happens instead of tossing the error back out, we\n         * should silently just ignore\n         * it.\n         */\n      }\n    });\n  }\n\n  if ('cookies' in request && request.cookies.length) {\n    /**\n     * As the browser fetch API can't set custom cookies for requests, they instead need to be\n     * defined on the document and passed into the request via `credentials: include`. Since this\n     * is a browser-specific quirk, that should only\n     * happen in browsers!\n     */\n    if (isBrowser()) {\n      request.cookies.forEach(cookie => {\n        document.cookie = `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`;\n      });\n\n      options.credentials = 'include';\n    } else {\n      headers.append(\n        'cookie',\n        request.cookies\n          .map(cookie => `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`)\n          .join('; '),\n      );\n    }\n  }\n\n  if ('postData' in request) {\n    if (request.postData && 'params' in request.postData) {\n      if (!('mimeType' in request.postData)) {\n        // @ts-expect-error HAR spec requires that `mimeType` is always present but it might not be.\n        request.postData.mimeType = 'application/octet-stream';\n      }\n\n      switch (request.postData.mimeType) {\n        case 'application/x-www-form-urlencoded':\n          /**\n           * Since the content we're handling here is to be encoded as\n           * `application/x-www-form-urlencoded`, this should override any other `Content-Type`\n           * headers that are present in the HAR. This is how Postman handles this case when\n           * building code snippets!\n           *\n           * @see {@link https://github.com/github/fetch/issues/263#issuecomment-209530977}\n           */\n          headers.set('Content-Type', request.postData.mimeType);\n\n          const encodedParams = new URLSearchParams();\n          request.postData.params?.forEach(param => {\n            if (param.value) encodedParams.set(param.name, param.value);\n          });\n\n          options.body = encodedParams.toString();\n          break;\n\n        case 'multipart/alternative':\n        case 'multipart/form-data':\n        case 'multipart/mixed':\n        case 'multipart/related':\n          /**\n           * If there's a `Content-Type` header set we need to remove it. We're doing this because\n           * when we pass the form data object into `fetch` that'll set a proper `Content-Type`\n           * header for this request that also includes the boundary used on the content.\n           *\n           * If we don't do this, then consumers won't be able to parse out the payload because\n           * they won't know what the boundary to split on it.\n           */\n          if (headers.has('Content-Type')) {\n            headers.delete('Content-Type');\n          }\n\n          const form = new FormData();\n\n          request.postData.params?.forEach(param => {\n            if ('fileName' in param && param.fileName) {\n              if (opts.files) {\n                const fileContents = getFileFromSuppliedFiles(param.fileName, opts.files);\n                if (fileContents) {\n                  // If the file we've got available to us is a Buffer then we need to convert it so\n                  // that the FormData API can use it.\n                  if (isBuffer(fileContents)) {\n                    form.append(\n                      param.name,\n                      new File([fileContents], param.fileName, {\n                        type: param.contentType || undefined,\n                      }),\n                      param.fileName,\n                    );\n\n                    return;\n                  } else if (isFile(fileContents)) {\n                    form.append(param.name, fileContents as Blob, param.fileName);\n                    return;\n                  }\n\n                  throw new TypeError(\n                    'An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects.',\n                  );\n                }\n              }\n\n              if ('value' in param && param.value) {\n                let paramBlob;\n                const parsed = parseDataUrl(param.value);\n                if (parsed) {\n                  // If we were able to parse out this data URL we don't need to transform its data\n                  // into a buffer for `Blob` because that supports data URLs already.\n                  paramBlob = new Blob([param.value], { type: parsed.contentType || param.contentType || undefined });\n                } else {\n                  paramBlob = new Blob([param.value], { type: param.contentType || undefined });\n                }\n\n                form.append(param.name, paramBlob, param.fileName);\n                return;\n              }\n\n              throw new Error(\n                \"The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file.\",\n              );\n            }\n\n            if (param.value) form.append(param.name, param.value);\n          });\n\n          options.body = form;\n          break;\n\n        default:\n          const formBody: Record<string, unknown> = {};\n          request.postData.params?.map(param => {\n            try {\n              formBody[param.name] = JSON.parse(param.value || '');\n            } catch (e) {\n              formBody[param.name] = param.value;\n            }\n\n            return true;\n          });\n\n          options.body = JSON.stringify(formBody);\n      }\n    } else if (request.postData?.text?.length) {\n      // If we've got `files` map content present, and this post data content contains a valid data\n      // URL then we can substitute the payload with that file instead of the using data URL.\n      if (opts.files) {\n        const parsed = parseDataUrl(request.postData.text) as DataURL;\n        if (parsed) {\n          if (parsed?.name && parsed.name in opts.files) {\n            const fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);\n            if (fileContents) {\n              if (isBuffer(fileContents)) {\n                options.body = fileContents;\n              } else if (isFile(fileContents)) {\n                // `Readable.from` isn't available in browsers but the browser `Request` object can\n                // handle `File` objects just fine without us having to mold it into shape.\n                if (isBrowser()) {\n                  options.body = fileContents;\n                } else {\n                  options.body = (fileContents as File).stream();\n                  shouldSetDuplex = true;\n\n                  // Supplying a polyfilled `File` stream into `Request.body` doesn't automatically\n                  // add `Content-Length`.\n                  if (!headers.has('content-length')) {\n                    headers.set('content-length', String((fileContents as File).size));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (typeof options.body === 'undefined') {\n        options.body = request.postData.text;\n      }\n    }\n\n    /**\n     * The fetch spec, which Node 18+ strictly abides by, now requires that `duplex` be sent with\n     * requests that have payloads.\n     *\n     * As `RequestInit#duplex` isn't supported by any browsers, or even mentioned on MDN, we aren't\n     * sending it in browser environments. This work is purely to support Node 18+ and `undici`\n     * environments.\n     *\n     * @see {@link https://github.com/nodejs/node/issues/46221}\n     * @see {@link https://github.com/whatwg/fetch/pull/1457}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request/Request}\n     */\n    if (shouldSetDuplex && !isBrowser()) {\n      options.duplex = 'half';\n    }\n  }\n\n  // We automaticaly assume that the HAR that we have already has query parameters encoded within\n  // it so we do **not** use the `URLSearchParams` API here for composing the query string.\n  let requestURL = url;\n  if ('queryString' in request && request.queryString.length) {\n    const urlObj = new URL(requestURL);\n\n    const queryParams = Array.from(urlObj.searchParams).map(([k, v]) => `${k}=${v}`);\n    request.queryString.forEach(q => {\n      queryParams.push(`${q.name}=${q.value}`);\n    });\n\n    querystring = queryParams.join('&');\n\n    // Because anchor hashes before query strings will prevent query strings from being delivered\n    // we need to pop them off and re-add them after.\n    if (urlObj.hash) {\n      const urlWithoutHashes = requestURL.replace(urlObj.hash, '');\n      requestURL = `${urlWithoutHashes.split('?')[0]}${querystring ? `?${querystring}` : ''}`;\n      requestURL += urlObj.hash;\n    } else {\n      requestURL = `${requestURL.split('?')[0]}${querystring ? `?${querystring}` : ''}`;\n    }\n  }\n\n  if (opts.userAgent) {\n    headers.append('User-Agent', opts.userAgent);\n  }\n\n  options.headers = headers;\n\n  return fetch(requestURL, options);\n}\n"],"mappings":"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","names":[]}