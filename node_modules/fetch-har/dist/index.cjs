"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var _dataurls = require('@readme/data-urls');
function isBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function isBuffer(value) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(value);
}
function isFile(value) {
  if (value instanceof File) {
    return value.constructor.name === "File";
  }
  return false;
}
function getFileFromSuppliedFiles(filename, files) {
  if (files && filename in files) {
    return files[filename];
  } else if (files && decodeURIComponent(filename) in files) {
    return files[decodeURIComponent(filename)];
  }
  return false;
}
function fetchHAR(_0) {
  return __async(this, arguments, function* (har, opts = {}) {
    var _a, _b, _c, _d, _e;
    if (!har)
      throw new Error("Missing HAR definition");
    if (!har.log || !har.log.entries || !har.log.entries.length)
      throw new Error("Missing log.entries array");
    if (!globalThis.Blob) {
      try {
        const NodeBlob = (yield Promise.resolve().then(() => _interopRequireWildcard(require("buffer")))).Blob;
        globalThis.Blob = NodeBlob;
      } catch (e) {
        throw new Error(
          "The Blob API is required for this library. https://developer.mozilla.org/en-US/docs/Web/API/Blob"
        );
      }
    }
    if (!globalThis.File) {
      try {
        const NodeFile = (yield Promise.resolve().then(() => _interopRequireWildcard(require("buffer")))).File;
        globalThis.File = NodeFile;
      } catch (e) {
        throw new Error(
          "The File API is required for this library. https://developer.mozilla.org/en-US/docs/Web/API/File"
        );
      }
    }
    const { request } = har.log.entries[0];
    const { url } = request;
    let querystring = "";
    let shouldSetDuplex = false;
    const options = __spreadProps(__spreadValues({}, opts.init ? opts.init : {}), {
      method: request.method
    });
    if (!options.headers) {
      options.headers = new Headers();
    } else if (typeof options.headers === "object" && !(options.headers instanceof Headers) && options.headers !== null) {
      options.headers = new Headers(options.headers);
    }
    const headers = options.headers;
    if ("headers" in request && request.headers.length) {
      request.headers.forEach((header) => {
        try {
          return headers.append(header.name, header.value);
        } catch (err) {
        }
      });
    }
    if ("cookies" in request && request.cookies.length) {
      if (isBrowser()) {
        request.cookies.forEach((cookie) => {
          document.cookie = `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`;
        });
        options.credentials = "include";
      } else {
        headers.append(
          "cookie",
          request.cookies.map((cookie) => `${encodeURIComponent(cookie.name)}=${encodeURIComponent(cookie.value)}`).join("; ")
        );
      }
    }
    if ("postData" in request) {
      if (request.postData && "params" in request.postData) {
        if (!("mimeType" in request.postData)) {
          request.postData.mimeType = "application/octet-stream";
        }
        switch (request.postData.mimeType) {
          case "application/x-www-form-urlencoded":
            headers.set("Content-Type", request.postData.mimeType);
            const encodedParams = new URLSearchParams();
            (_a = request.postData.params) == null ? void 0 : _a.forEach((param) => {
              if (param.value)
                encodedParams.set(param.name, param.value);
            });
            options.body = encodedParams.toString();
            break;
          case "multipart/alternative":
          case "multipart/form-data":
          case "multipart/mixed":
          case "multipart/related":
            if (headers.has("Content-Type")) {
              headers.delete("Content-Type");
            }
            const form = new FormData();
            (_b = request.postData.params) == null ? void 0 : _b.forEach((param) => {
              if ("fileName" in param && param.fileName) {
                if (opts.files) {
                  const fileContents = getFileFromSuppliedFiles(param.fileName, opts.files);
                  if (fileContents) {
                    if (isBuffer(fileContents)) {
                      form.append(
                        param.name,
                        new File([fileContents], param.fileName, {
                          type: param.contentType || void 0
                        }),
                        param.fileName
                      );
                      return;
                    } else if (isFile(fileContents)) {
                      form.append(param.name, fileContents, param.fileName);
                      return;
                    }
                    throw new TypeError(
                      "An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects."
                    );
                  }
                }
                if ("value" in param && param.value) {
                  let paramBlob;
                  const parsed = _dataurls.parse.call(void 0, param.value);
                  if (parsed) {
                    paramBlob = new Blob([param.value], { type: parsed.contentType || param.contentType || void 0 });
                  } else {
                    paramBlob = new Blob([param.value], { type: param.contentType || void 0 });
                  }
                  form.append(param.name, paramBlob, param.fileName);
                  return;
                }
                throw new Error(
                  "The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file."
                );
              }
              if (param.value)
                form.append(param.name, param.value);
            });
            options.body = form;
            break;
          default:
            const formBody = {};
            (_c = request.postData.params) == null ? void 0 : _c.map((param) => {
              try {
                formBody[param.name] = JSON.parse(param.value || "");
              } catch (e) {
                formBody[param.name] = param.value;
              }
              return true;
            });
            options.body = JSON.stringify(formBody);
        }
      } else if ((_e = (_d = request.postData) == null ? void 0 : _d.text) == null ? void 0 : _e.length) {
        if (opts.files) {
          const parsed = _dataurls.parse.call(void 0, request.postData.text);
          if (parsed) {
            if ((parsed == null ? void 0 : parsed.name) && parsed.name in opts.files) {
              const fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);
              if (fileContents) {
                if (isBuffer(fileContents)) {
                  options.body = fileContents;
                } else if (isFile(fileContents)) {
                  if (isBrowser()) {
                    options.body = fileContents;
                  } else {
                    options.body = fileContents.stream();
                    shouldSetDuplex = true;
                    if (!headers.has("content-length")) {
                      headers.set("content-length", String(fileContents.size));
                    }
                  }
                }
              }
            }
          }
        }
        if (typeof options.body === "undefined") {
          options.body = request.postData.text;
        }
      }
      if (shouldSetDuplex && !isBrowser()) {
        options.duplex = "half";
      }
    }
    let requestURL = url;
    if ("queryString" in request && request.queryString.length) {
      const urlObj = new URL(requestURL);
      const queryParams = Array.from(urlObj.searchParams).map(([k, v]) => `${k}=${v}`);
      request.queryString.forEach((q) => {
        queryParams.push(`${q.name}=${q.value}`);
      });
      querystring = queryParams.join("&");
      if (urlObj.hash) {
        const urlWithoutHashes = requestURL.replace(urlObj.hash, "");
        requestURL = `${urlWithoutHashes.split("?")[0]}${querystring ? `?${querystring}` : ""}`;
        requestURL += urlObj.hash;
      } else {
        requestURL = `${requestURL.split("?")[0]}${querystring ? `?${querystring}` : ""}`;
      }
    }
    if (opts.userAgent) {
      headers.append("User-Agent", opts.userAgent);
    }
    options.headers = headers;
    return fetch(requestURL, options);
  });
}


exports.default = fetchHAR;

module.exports = exports.default//# sourceMappingURL=index.cjs.map